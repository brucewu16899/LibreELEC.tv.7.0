From a41bddf1d844584f771cca0c4ddefeab321bddb6 Mon Sep 17 00:00:00 2001
From: Jamie Coldhill <wrxtasy@amnet.net.au>
Date: Wed, 27 Jul 2016 19:50:16 +0800
Subject: [PATCH] CEC add ao_cec hybrid driver

---
 drivers/amlogic/Kconfig                            |    2 +
 drivers/amlogic/Makefile                           |    2 +
 drivers/amlogic/cec/Kconfig                        |    9 +
 drivers/amlogic/cec/Makefile                       |    1 +
 drivers/amlogic/cec/hdmi_ao_cec.c                  | 2055 ++++++++++++++++++++
 drivers/amlogic/cec/hdmi_ao_cec.h                  |  179 ++
 drivers/amlogic/hdmi/Kconfig                       |   10 +
 drivers/amlogic/hdmi/hdmi_tx_20/Makefile           |   14 +-
 drivers/amlogic/hdmi/hdmi_tx_20/amlogic_cec.c      |  710 +++++++
 drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_cec.c      |   71 +-
 drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c     |   62 +-
 drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_hdcp.c     |   63 +-
 drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c     |  474 ++---
 drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_scdc.c     |    1 -
 drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c    |  188 +-
 drivers/amlogic/hdmi/hdmi_tx_20/hw/Makefile        |    5 +-
 drivers/amlogic/hdmi/hdmi_tx_20/hw/enc_cfg_hw.c    |  454 +++++
 .../amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_cec_hw.c    |    8 +
 drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c    |  730 ++++---
 drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_reg.h   |    4 -
 drivers/amlogic/hdmi/hdmi_tx_20/hw/mach_reg.h      |    1 -
 drivers/amlogic/hdmi/hdmi_tx_20/hw/reg_ops.c       |   38 +-
 include/linux/amlogic/hdmi_tx/hdmi_common.h        |   22 +-
 include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h        |    3 +
 include/linux/amlogic/hdmi_tx/hdmi_tx_cec_20.h     |  361 ++++
 include/linux/amlogic/hdmi_tx/hdmi_tx_module.h     |   17 +-
 26 files changed, 4716 insertions(+), 768 deletions(-)
 create mode 100644 drivers/amlogic/cec/Kconfig
 create mode 100644 drivers/amlogic/cec/Makefile
 create mode 100644 drivers/amlogic/cec/hdmi_ao_cec.c
 create mode 100644 drivers/amlogic/cec/hdmi_ao_cec.h
 create mode 100644 drivers/amlogic/hdmi/hdmi_tx_20/amlogic_cec.c
 create mode 100644 include/linux/amlogic/hdmi_tx/hdmi_tx_cec_20.h

diff --git a/drivers/amlogic/Kconfig b/drivers/amlogic/Kconfig
index ded3ff3..1a54291 100644
--- a/drivers/amlogic/Kconfig
+++ b/drivers/amlogic/Kconfig
@@ -3,6 +3,8 @@
 #
 menu "Amlogic Device Drivers"
 
+source "drivers/amlogic/cec/Kconfig"
+
 source "drivers/amlogic/clocksource/Kconfig"
 
 source "drivers/amlogic/uart/Kconfig"
diff --git a/drivers/amlogic/Makefile b/drivers/amlogic/Makefile
index 7e49564..fecfd44 100644
--- a/drivers/amlogic/Makefile
+++ b/drivers/amlogic/Makefile
@@ -116,6 +116,8 @@ obj-$(CONFIG_AML_WDT)  		+= watchdog/
 
 obj-$(CONFIG_INSTABOOT)		+= instaboot/
 
+obj-$(CONFIG_AML_AO_CEC) 	+= cec/
+
 obj-$(CONFIG_UMP)               += gpu/ump/
 
 obj-$(CONFIG_MALI400)           += gpu/mali/
diff --git a/drivers/amlogic/cec/Kconfig b/drivers/amlogic/cec/Kconfig
new file mode 100644
index 0000000..ff4d159
--- /dev/null
+++ b/drivers/amlogic/cec/Kconfig
@@ -0,0 +1,9 @@
+menu "AO CEC Support"
+
+config AML_AO_CEC
+	boolean "HDMI AO cec driver support"
+	help
+		HDMI AO cec driver provide cec support on Amlogic SOC chips, you can
+		use this driver to implement cec features on TV/MBOX
+
+endmenu
diff --git a/drivers/amlogic/cec/Makefile b/drivers/amlogic/cec/Makefile
new file mode 100644
index 0000000..1c16a4b
--- /dev/null
+++ b/drivers/amlogic/cec/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_AML_AO_CEC)  += hdmi_ao_cec.o
diff --git a/drivers/amlogic/cec/hdmi_ao_cec.c b/drivers/amlogic/cec/hdmi_ao_cec.c
new file mode 100644
index 0000000..21ca8bb
--- /dev/null
+++ b/drivers/amlogic/cec/hdmi_ao_cec.c
@@ -0,0 +1,2055 @@
+/*
+ * drivers/amlogic/cec/hdmi_ao_cec.c
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/irq.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <linux/switch.h>
+#include <linux/workqueue.h>
+#include <linux/timer.h>
+
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/amlogic/tvin/tvin.h>
+#include <linux/wakelock_android.h>
+
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec_20.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/of_irq.h>
+#include "hdmi_ao_cec.h"
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/amlogic/pm.h>
+#include <linux/of_address.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+static struct early_suspend aocec_suspend_handler;
+#endif
+
+
+#define CEC_FRAME_DELAY     msecs_to_jiffies(400)
+#define CEC_DEV_NAME        "cec"
+
+#define DEV_TYPE_TX     4
+#define DEV_TYPE_RX     0
+
+#define CEC_EARLY_SUSPEND   (1 << 0)
+#define CEC_DEEP_SUSPEND    (1 << 1)
+
+/* global struct for tx and rx */
+struct ao_cec_dev {
+    unsigned long dev_type;
+    unsigned int port_num;
+    unsigned int arc_port;
+    unsigned int hal_flag;
+    unsigned int phy_addr;
+    unsigned int port_seq;
+    unsigned long irq_cec;
+    void __iomem *exit_reg;
+    void __iomem *cec_reg;
+    void __iomem *hdmi_rxreg;
+    struct hdmitx_dev *tx_dev;
+    struct workqueue_struct *cec_thread;
+    struct device *dbg_dev;
+    struct delayed_work cec_work;
+    struct completion rx_ok;
+    struct completion tx_ok;
+    spinlock_t cec_reg_lock;
+    struct mutex cec_mutex;
+#ifdef CONFIG_PM
+    int cec_suspend;
+#endif
+    struct vendor_info_data v_data;
+    struct cec_global_info_t cec_info;
+};
+
+static int phy_addr_test;
+
+/* from android cec hal */
+enum {
+    HDMI_OPTION_WAKEUP = 1,
+    HDMI_OPTION_ENABLE_CEC = 2,
+    HDMI_OPTION_SYSTEM_CEC_CONTROL = 3,
+    HDMI_OPTION_SET_LANG = 5,
+};
+
+static struct ao_cec_dev *cec_dev;
+static int cec_tx_result;
+
+static unsigned char rx_msg[MAX_MSG];
+static unsigned char rx_len;
+static unsigned int  new_msg;
+bool cec_msg_dbg_en = 0;
+
+#define CEC_ERR(format, args...)                \
+    {if (cec_dev->dbg_dev)                  \
+        dev_err(cec_dev->dbg_dev, "%s(): " format, __func__, ##args);  \
+    }
+
+#define CEC_INFO(format, args...)               \
+    {if (cec_msg_dbg_en && cec_dev->dbg_dev)        \
+        dev_info(cec_dev->dbg_dev, "%s(): " format, __func__, ##args); \
+    }
+
+static unsigned char msg_log_buf[128] = { 0 };
+
+#define waiting_aocec_free() \
+    do {\
+        unsigned long cnt = 0;\
+        while (readl(cec_dev->cec_reg + AO_CEC_RW_REG) & (1<<23)) {\
+            if (3500 == cnt++) { \
+                pr_info("waiting aocec free time out.\n");\
+                break;\
+            } \
+        } \
+    } while (0)
+
+#define HR_DELAY(n)     (ktime_set(0, n * 1000 * 1000))
+__u16 cec_key_map[160] = {
+    KEY_ENTER, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, 0 , 0 , 0 ,//0x00
+    0 , KEY_HOMEPAGE , KEY_MENU, 0, 0, KEY_BACK, 0, 0,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x10
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    KEY_0 , KEY_1, KEY_2, KEY_3,KEY_4, KEY_5, KEY_6, KEY_7,//0x20
+    KEY_8 , KEY_9, KEY_DOT, 0, 0, 0, 0, 0,
+    KEY_CHANNELUP , KEY_CHANNELDOWN, KEY_CHANNEL, 0, 0, 0, 0, 0,//0x30
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    
+    KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, KEY_RECORD,//0x40
+    KEY_REWIND, KEY_FASTFORWARD, KEY_EJECTCD, KEY_NEXTSONG, KEY_PREVIOUSSONG, 0, 0, 0,
+    0 , 0, 0, KEY_PROGRAM, 0, 0, 0, 0,//0x50
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    KEY_PLAYCD, KEY_PLAYPAUSE, KEY_RECORD, KEY_PAUSECD, KEY_STOPCD, KEY_MUTE, 0, KEY_TUNER,//0x60
+    0 , KEY_MEDIA, 0, 0, KEY_POWER, 0, 0, 0,
+    0 , KEY_BLUE, KEY_RED, KEY_GREEN, KEY_YELLOW, 0, 0, 0,//0x70
+    0 , 0, 0, 0, 0, 0, 0, 0x2fd,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x80
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    0 , KEY_EXIT, 0, 0, 0, 0, KEY_PVR, 0,//0x90  //samsung vendor buttons return and channel_list
+    0 , 0, 0, 0, 0, 0, 0, 0,
+};
+
+struct hrtimer cec_key_timer;
+static int last_key_irq = -1;
+static int key_value = 1;
+enum hrtimer_restart cec_key_up(struct hrtimer *timer)
+{
+    if (key_value == 1){
+        input_event(cec_dev->cec_info.remote_cec_dev,
+            EV_KEY, cec_key_map[last_key_irq], 0);
+    }
+    input_sync(cec_dev->cec_info.remote_cec_dev);
+    CEC_INFO("last:%d up\n", cec_key_map[last_key_irq]);
+    key_value = 2;
+
+    return HRTIMER_NORESTART;
+}
+
+void cec_user_control_pressed_irq(unsigned char message_irq)
+{
+    if (message_irq < 160) {
+        CEC_INFO("Key pressed: %d\n", message_irq);
+        input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY,
+                cec_key_map[message_irq], key_value);
+        input_sync(cec_dev->cec_info.remote_cec_dev);
+        last_key_irq = message_irq;
+        hrtimer_start(&cec_key_timer, HR_DELAY(200), HRTIMER_MODE_REL);
+        CEC_INFO(":key map:%d\n", cec_key_map[message_irq]);
+    }
+}
+
+void cec_user_control_released_irq(void)
+{
+    /*
+     * key must be valid
+     */
+    if (last_key_irq != -1) {
+        CEC_INFO("Key released: %d\n",last_key_irq);
+        hrtimer_cancel(&cec_key_timer);
+        input_event(cec_dev->cec_info.remote_cec_dev,
+            EV_KEY, cec_key_map[last_key_irq], 0);
+        input_sync(cec_dev->cec_info.remote_cec_dev);
+        key_value = 1;
+    }
+}
+
+void cec_set_reg_bits(unsigned int addr, unsigned int value,
+    unsigned int offset, unsigned int len)
+{
+    unsigned int data32 = 0;
+
+    data32 = readl(cec_dev->cec_reg + addr);
+    data32 &= ~(((1 << len) - 1) << offset);
+    data32 |= (value & ((1 << len) - 1)) << offset;
+    writel(data32, cec_dev->cec_reg + addr);
+}
+
+unsigned int aocec_rd_reg(unsigned long addr)
+{
+    unsigned int data32;
+    unsigned long flags;
+    waiting_aocec_free();
+    spin_lock_irqsave(&cec_dev->cec_reg_lock, flags);
+    data32 = 0;
+    data32 |= 0 << 16; /* [16]   cec_reg_wr */
+    data32 |= 0 << 8; /* [15:8]   cec_reg_wrdata */
+    data32 |= addr << 0; /* [7:0]   cec_reg_addr */
+    writel(data32, cec_dev->cec_reg + AO_CEC_RW_REG);
+
+    waiting_aocec_free();
+    data32 = ((readl(cec_dev->cec_reg + AO_CEC_RW_REG)) >> 24) & 0xff;
+    spin_unlock_irqrestore(&cec_dev->cec_reg_lock, flags);
+    return data32;
+} /* aocec_rd_reg */
+
+void aocec_wr_reg(unsigned long addr, unsigned long data)
+{
+    unsigned long data32;
+    unsigned long flags;
+    waiting_aocec_free();
+    spin_lock_irqsave(&cec_dev->cec_reg_lock, flags);
+    data32 = 0;
+    data32 |= 1 << 16; /* [16]   cec_reg_wr */
+    data32 |= data << 8; /* [15:8]   cec_reg_wrdata */
+    data32 |= addr << 0; /* [7:0]   cec_reg_addr */
+    writel(data32, cec_dev->cec_reg + AO_CEC_RW_REG);
+    spin_unlock_irqrestore(&cec_dev->cec_reg_lock, flags);
+} /* aocec_wr_only_reg */
+
+static void cec_enable_irq(void)
+{
+    cec_set_reg_bits(AO_CEC_INTR_MASKN, 0x6, 0, 3);
+    CEC_INFO("enable:int mask:0x%x\n",
+         readl(cec_dev->cec_reg + AO_CEC_INTR_MASKN));
+}
+
+static void cec_hw_buf_clear(void)
+{
+    aocec_wr_reg(CEC_RX_MSG_CMD, RX_DISABLE);
+    aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+    aocec_wr_reg(CEC_RX_CLEAR_BUF, 1);
+    aocec_wr_reg(CEC_TX_CLEAR_BUF, 1);
+    udelay(100);
+    aocec_wr_reg(CEC_RX_CLEAR_BUF, 0);
+    aocec_wr_reg(CEC_TX_CLEAR_BUF, 0);
+    udelay(100);
+    aocec_wr_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+    aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+}
+
+void cec_logicaddr_clear(void)
+{
+    int i;
+    for (i = 0; i < 5; i++) {
+        aocec_wr_reg((CEC_LOGICAL_ADDR0 + i), 0);
+        cec_dev->cec_info.log_addr[i] = 0;
+        udelay(100);
+    }
+    cec_hw_buf_clear();
+}
+
+void cec_logicaddr_setByMask(unsigned int mask)
+{
+    int i, j;
+    int reg = 0;
+    int primary = -1;
+    // ignore reserved device type
+    const int device_types[5] = {CEC_RECORDING_DEVICE, 
+                                 CEC_PLAYBACK_DEVICE, 
+                                 CEC_TUNER_DEVICE,
+                                 CEC_AUDIO_SYSTEM_DEVICE,
+                                 CEC_DISPLAY_DEVICE|CEC_UNREGISTERED 
+                                 };
+    mask &= 0xffff;
+
+    if (mask == 0) {
+        cec_logicaddr_clear();
+        return;
+    }
+
+    for (i = CEC_TV_ADDR; i <= CEC_UNREGISTERED_ADDR; i++) {
+        if (reg > 4) {
+            break;
+        }
+        if ((mask & 1<<i) == 1<<i) {
+            for (j = 0; j <= sizeof(device_types); j++) {
+                // Max. one of each type
+                if (1<<i & device_types[j]) {
+                    CEC_INFO("ADDING LA:0x%d reg:0x%d\n", i, 
+                            (CEC_LOGICAL_ADDR0 + reg));
+                    mask &= ~(mask & device_types[j]);
+                    cec_dev->cec_info.log_addr[reg] = i;
+                    cec_logicaddr_set(i, (CEC_LOGICAL_ADDR0 + reg));
+                    if (primary == -1);
+                        primary = i;
+                        cec_logicaddr_config(primary, 1);
+                    reg++;
+                    break;
+                }
+            }
+        }
+    }
+}
+
+void cec_logicaddr_set(int logicaddr, int logreg)
+{
+    aocec_wr_reg(logreg, 0);
+    cec_hw_buf_clear();
+    aocec_wr_reg(logreg, (logicaddr & 0xf));
+    udelay(100);
+    aocec_wr_reg(logreg, (0x1 << 4) | (logicaddr & 0xf));
+    if (cec_msg_dbg_en)
+        CEC_INFO("set logical addr:0x%x\n",
+            aocec_rd_reg(logreg));
+}
+
+static void cec_hw_reset(void)
+{
+    writel(0x1, cec_dev->cec_reg + AO_CEC_GEN_CNTL);
+    /* Enable gated clock (Normal mode). */
+    cec_set_reg_bits(AO_CEC_GEN_CNTL, 1, 1, 1);
+    /* Release SW reset */
+    udelay(100);
+    cec_set_reg_bits(AO_CEC_GEN_CNTL, 0, 0, 1);
+
+    /* Enable all AO_CEC interrupt sources */
+    cec_set_reg_bits(AO_CEC_INTR_MASKN, 0x6, 0, 3);
+
+    cec_logicaddr_set(cec_dev->cec_info.log_addr[0], CEC_LOGICAL_ADDR0);
+
+    /* Cec arbitration 3/5/7 bit time set. */
+    cec_arbit_bit_time_set(3, 0x118, 0);
+    cec_arbit_bit_time_set(5, 0x000, 0);
+    cec_arbit_bit_time_set(7, 0x2aa, 0);
+
+    CEC_INFO("hw reset :logical addr:0x%x\n",
+        aocec_rd_reg(CEC_LOGICAL_ADDR0));
+}
+
+void cec_rx_buf_clear(void)
+{
+    aocec_wr_reg(CEC_RX_CLEAR_BUF, 0x1);
+    aocec_wr_reg(CEC_RX_CLEAR_BUF, 0x0);
+    CEC_INFO("rx buf clean\n");
+}
+
+int cec_rx_buf_check(void)
+{
+    unsigned int rx_num_msg = aocec_rd_reg(CEC_RX_NUM_MSG);
+    if (rx_num_msg)
+        CEC_INFO("rx msg num:0x%02x\n", rx_num_msg);
+
+    return rx_num_msg;
+}
+
+int cec_ll_rx(unsigned char *msg, unsigned char *len)
+{
+    int i;
+    int ret = -1;
+    int pos;
+    int rx_stat;
+
+    rx_stat = aocec_rd_reg(CEC_RX_MSG_STATUS);
+    if ((RX_DONE != rx_stat) || (1 != aocec_rd_reg(CEC_RX_NUM_MSG))) {
+        CEC_INFO("rx status:%x\n", rx_stat);
+        writel((1 << 2), cec_dev->cec_reg + AO_CEC_INTR_CLR);
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_NO_OP);
+        return ret;
+    }
+
+    *len = aocec_rd_reg(CEC_RX_MSG_LENGTH) + 1;
+
+    for (i = 0; i < (*len) && i < MAX_MSG; i++)
+        msg[i] = aocec_rd_reg(CEC_RX_MSG_0_HEADER + i);
+
+    ret = rx_stat;
+
+    /* ignore ping message */
+    if (cec_msg_dbg_en  == 1 && *len > 1) {
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos,
+            "CEC: rx msg len: %d   dat: ", *len);
+        for (i = 0; i < (*len); i++)
+            pos += sprintf(msg_log_buf + pos, "%02x ", msg[i]);
+        pos += sprintf(msg_log_buf + pos, "\n");
+        msg_log_buf[pos] = '\0';
+        CEC_INFO("%s", msg_log_buf);
+    }
+    writel((1 << 2), cec_dev->cec_reg + AO_CEC_INTR_CLR);
+    aocec_wr_reg(CEC_RX_MSG_CMD, RX_ACK_NEXT);
+    aocec_wr_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+    return ret;
+}
+
+void cec_polling_online_dev(int log_addr, int *bool)
+{
+    unsigned int r;
+    unsigned char msg[1];
+    int retry = 5;
+
+    msg[0] = (log_addr<<4) | log_addr;
+    /* set broadcast address first */
+    cec_logicaddr_set(0xf, CEC_LOGICAL_ADDR0);
+    if (cec_msg_dbg_en == 1)
+        CEC_INFO("CEC_LOGICAL_ADDR0:0x%i\n",
+               aocec_rd_reg(CEC_LOGICAL_ADDR0));
+    while (retry) {
+        r = cec_ll_tx(msg, 1);
+        if (r == CEC_FAIL_BUSY) {
+            retry--;
+            CEC_INFO("try log addr %x busy, retry:%d\n",
+                   log_addr, retry);
+            /*
+             * try to reset CEC if tx busy is found
+             */
+            cec_hw_reset();
+        } else
+            break;
+    }
+
+    if (r == CEC_FAIL_NACK) {
+        *bool = 0;
+    } else if (r == CEC_FAIL_NONE) {
+        *bool = 1;
+    }
+    CEC_INFO("CEC: poll online logic device: 0x%x BOOL: %d\n",
+        log_addr, *bool);
+}
+
+/************************ cec arbitration cts code **************************/
+/* using the cec pin as fiq gpi to assist the bus arbitration */
+
+/* return value: 1: successful    0: error */
+static int cec_ll_trigle_tx(const unsigned char *msg, int len)
+{
+    int i;
+    unsigned int n;
+    int pos;
+    int reg;
+    unsigned int j = 20;
+    unsigned tx_stat;
+    static int cec_timeout_cnt = 1;
+	int flag = 0;
+
+    while (1) {
+        tx_stat = aocec_rd_reg(CEC_TX_MSG_STATUS);
+        if (tx_stat != TX_BUSY)
+            break;
+
+		if (!flag && tx_stat == TX_BUSY) {
+            CEC_INFO("TX is busy. Sending TX_ABORT\n");
+			aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+			flag = 1;
+		}
+
+        if (!(j--)) {
+            CEC_INFO("TX is still busy. Sending TX_NO_OP\n");
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            cec_timeout_cnt++;
+            if (cec_timeout_cnt > 0x08) {
+                cec_hw_reset();
+                break;
+            }
+        }
+        msleep(20);
+    }
+
+    reg = aocec_rd_reg(CEC_TX_MSG_STATUS);
+    if (reg == TX_IDLE || reg == TX_DONE) {
+        for (i = 0; i < len; i++)
+            aocec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
+
+        aocec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
+        aocec_wr_reg(CEC_TX_MSG_CMD, TX_REQ_CURRENT);
+
+        if (cec_msg_dbg_en  == 1) {
+            pos = 0;
+            pos += sprintf(msg_log_buf + pos,
+                       "CEC: tx msg len: %d   dat: ", len);
+            for (n = 0; n < len; n++) {
+                pos += sprintf(msg_log_buf + pos,
+                           "%02x ", msg[n]);
+            }
+
+            pos += sprintf(msg_log_buf + pos, "\n");
+
+            msg_log_buf[pos] = '\0';
+            pr_info("%s", msg_log_buf);
+        }
+        cec_timeout_cnt = 0;
+        return 0;
+    }
+    return -1;
+}
+
+void tx_irq_handle(void)
+{
+    unsigned tx_status = aocec_rd_reg(CEC_TX_MSG_STATUS);
+    switch (tx_status) {
+    case TX_DONE:
+        aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+        cec_tx_result = 0;
+        complete(&cec_dev->tx_ok);
+        break;
+
+    case TX_BUSY:
+        CEC_ERR("TX_BUSY\n");
+        break;
+
+    case TX_ERROR:
+        if (cec_msg_dbg_en  == 1)
+            CEC_ERR("TX ERROR!!!\n");
+        if (RX_ERROR == aocec_rd_reg(CEC_RX_MSG_STATUS)) {
+            cec_hw_reset();
+        } else {
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+        }
+        cec_tx_result = 1;
+        complete(&cec_dev->tx_ok);
+        break;
+
+    case TX_IDLE:
+        break;
+    default:
+        break;
+    }
+    writel((1 << 1), cec_dev->cec_reg + AO_CEC_INTR_CLR);
+}
+
+/* Return value: < 0: fail, > 0: success */
+int cec_ll_tx(const unsigned char *msg, unsigned char len)
+{
+    int ret = 0;
+    int timeout = msecs_to_jiffies(1000);
+
+    if (len == 0)
+        return CEC_FAIL_NONE;
+
+    mutex_lock(&cec_dev->cec_mutex);
+    /*
+     * do not send messanges if tv is not support CEC
+     */
+    ret = cec_ll_trigle_tx(msg, len);
+    if (ret < 0) {
+        /* we should increase send idx if busy */
+        CEC_INFO("tx busy\n");
+        mutex_unlock(&cec_dev->cec_mutex);
+        return CEC_FAIL_BUSY;
+    }
+    cec_tx_result = 0;
+    ret = wait_for_completion_timeout(&cec_dev->tx_ok, timeout);
+    if (ret <= 0) {
+        /* timeout of interrupt */
+        ret = CEC_FAIL_OTHER;
+        CEC_INFO("tx timeout\n");
+    } else {
+        if (cec_tx_result)
+            ret = CEC_FAIL_NACK;
+        else
+            ret = CEC_FAIL_NONE;
+    }
+    mutex_unlock(&cec_dev->cec_mutex);
+
+    return ret;
+}
+
+/* -------------------------------------------------------------------------- */
+/* AO CEC0 config */
+/* -------------------------------------------------------------------------- */
+void ao_cec_init(void)
+{
+    unsigned long data32;
+    unsigned int reg;
+    /* Assert SW reset AO_CEC */
+    reg = readl(cec_dev->cec_reg + AO_CRT_CLK_CNTL1);
+    /* 24MHz/ (731 + 1) = 32786.885Hz */
+    reg &= ~(0x7ff << 16);
+    reg |= (731 << 16); /* divider from 24MHz */
+    reg |= (0x1 << 26);
+    reg &= ~(0x800 << 16);  /* select divider */
+    writel(reg, cec_dev->cec_reg + AO_CRT_CLK_CNTL1);
+    data32  = 0;
+    data32 |= 0 << 1;   /* [2:1]    cntl_clk: */
+                /* 0=Disable clk (Power-off mode); */
+                /* 1=Enable gated clock (Normal mode); */
+                /* 2=Enable free-run clk (Debug mode). */
+    data32 |= 1 << 0;   /* [0]    sw_reset: 1=Reset */
+    writel(data32, cec_dev->cec_reg + AO_CEC_GEN_CNTL);
+    /* Enable gated clock (Normal mode). */
+    cec_set_reg_bits(AO_CEC_GEN_CNTL, 1, 1, 1);
+    /* Release SW reset */
+    cec_set_reg_bits(AO_CEC_GEN_CNTL, 0, 0, 1);
+
+    /* Enable all AO_CEC interrupt sources */
+    cec_enable_irq();
+}
+
+void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag)
+{   /* 11bit:bit[10:0] */
+    if (flag) {
+        CEC_INFO("bit_set:0x%x;time_set:0x%x\n",
+            bit_set, time_set);
+    }
+
+    switch (bit_set) {
+    case 3:
+        /* 3 bit */
+        if (flag) {
+            CEC_INFO("read 3 bit:0x%x%x\n",
+                aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),
+                aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
+        }
+        aocec_wr_reg(AO_CEC_TXTIME_4BIT_BIT7_0, time_set & 0xff);
+        aocec_wr_reg(AO_CEC_TXTIME_4BIT_BIT10_8, (time_set >> 8) & 0x7);
+        if (flag) {
+            CEC_INFO("write 3 bit:0x%x%x\n",
+                aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),
+                aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
+        }
+        break;
+        /* 5 bit */
+    case 5:
+        if (flag) {
+            CEC_INFO("read 5 bit:0x%x%x\n",
+                aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8),
+                aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
+        }
+        aocec_wr_reg(AO_CEC_TXTIME_2BIT_BIT7_0, time_set & 0xff);
+        aocec_wr_reg(AO_CEC_TXTIME_2BIT_BIT10_8, (time_set >> 8) & 0x7);
+        if (flag) {
+            CEC_INFO("write 5 bit:0x%x%x\n",
+                aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8),
+                aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
+        }
+        break;
+        /* 7 bit */
+    case 7:
+        if (flag) {
+            CEC_INFO("read 7 bit:0x%x%x\n",
+                aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8),
+                aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
+        }
+        aocec_wr_reg(AO_CEC_TXTIME_17MS_BIT7_0, time_set & 0xff);
+        aocec_wr_reg(AO_CEC_TXTIME_17MS_BIT10_8, (time_set >> 8) & 0x7);
+        if (flag) {
+            CEC_INFO("write 7 bit:0x%x%x\n",
+                aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8),
+                aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
+        }
+        break;
+    default:
+        break;
+    }
+}
+
+static unsigned int ao_cec_intr_stat(void)
+{
+    return readl(cec_dev->cec_reg + AO_CEC_INTR_STAT);
+}
+
+unsigned int cec_intr_stat(void)
+{
+    return ao_cec_intr_stat();
+}
+
+/*
+ *wr_flag: 1 write; value valid
+ *       0 read;  value invalid
+ */
+unsigned int cec_config(unsigned int value, bool wr_flag)
+{
+    if (wr_flag)
+        cec_set_reg_bits(AO_DEBUG_REG0, value, 0, 8);
+
+    return readl(cec_dev->cec_reg + AO_DEBUG_REG0);
+}
+
+/*
+ *wr_flag:1 write; value valid
+ *      0 read;  value invalid
+ */
+unsigned int cec_phyaddr_config(unsigned int value, bool wr_flag)
+{
+    if (wr_flag)
+        cec_set_reg_bits(AO_DEBUG_REG1, value, 0, 16);
+
+    return readl(cec_dev->cec_reg + AO_DEBUG_REG1);
+}
+
+/*
+ *wr_flag:1 write; value valid
+ *      0 read;  value invalid
+ */
+unsigned int cec_logicaddr_config(unsigned int value, bool wr_flag)
+{
+    if (wr_flag)
+        cec_set_reg_bits(AO_DEBUG_REG3, value, 0, 8);
+
+    return readl(cec_dev->cec_reg + AO_DEBUG_REG3);
+}
+
+void cec_keep_reset(void)
+{
+    writel(0x1, cec_dev->cec_reg + AO_CEC_GEN_CNTL);
+}
+/*
+ * cec hw module init befor allocate logical address
+ */
+static void cec_pre_init(void)
+{
+    ao_cec_init();
+
+    cec_arbit_bit_time_set(3, 0x118, 0);
+    cec_arbit_bit_time_set(5, 0x000, 0);
+    cec_arbit_bit_time_set(7, 0x2aa, 0);
+}
+
+static int cec_late_check_rx_buffer(void)
+{
+    int ret;
+    struct delayed_work *dwork = &cec_dev->cec_work;
+
+    ret = cec_rx_buf_check();
+    if (!ret)
+        return 0;
+    /*
+     * start another check if rx buffer is full
+     */
+    if ((-1) == cec_ll_rx(rx_msg, &rx_len)) {
+        CEC_INFO("buffer got unrecorgnized msg\n");
+        cec_rx_buf_clear();
+        return 0;
+    } else {
+        mod_delayed_work(cec_dev->cec_thread, dwork, 0);
+        return 1;
+    }
+}
+
+void cec_key_report(int suspend)
+{
+    input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_POWER, 1);
+    input_sync(cec_dev->cec_info.remote_cec_dev);
+    input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_POWER, 0);
+    input_sync(cec_dev->cec_info.remote_cec_dev);
+    if (!suspend)
+        CEC_INFO("== WAKE UP BY CEC ==\n")
+    else
+        CEC_INFO("== SLEEP by CEC==\n")
+}
+
+void cec_give_version(unsigned int dest)
+{
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+    unsigned char msg[3];
+
+    if (0xf != dest) {
+        msg[0] = ((index & 0xf) << 4) | dest;
+        msg[1] = CEC_OC_CEC_VERSION;
+        msg[2] = CEC_VERSION_14A;
+        cec_ll_tx(msg, 3);
+    }
+}
+
+void cec_report_physical_address_smp(void)
+{
+    unsigned char msg[5];
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+    unsigned char phy_addr_ab, phy_addr_cd;
+
+    phy_addr_ab = (cec_dev->phy_addr >> 8) & 0xff;
+    phy_addr_cd = (cec_dev->phy_addr >> 0) & 0xff;
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_REPORT_PHYSICAL_ADDRESS;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+    msg[4] = cec_dev->dev_type;
+
+    cec_ll_tx(msg, 5);
+}
+
+void cec_device_vendor_id(void)
+{
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+    unsigned char msg[5];
+    unsigned int vendor_id;
+
+    vendor_id = cec_dev->v_data.vendor_id;
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_DEVICE_VENDOR_ID;
+    msg[2] = (vendor_id >> 16) & 0xff;
+    msg[3] = (vendor_id >> 8) & 0xff;
+    msg[4] = (vendor_id >> 0) & 0xff;
+
+    cec_ll_tx(msg, 5);
+}
+
+void cec_give_deck_status(unsigned int dest)
+{
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+    unsigned char msg[3];
+
+    msg[0] = ((index & 0xf) << 4) | dest;
+    msg[1] = CEC_OC_DECK_STATUS;
+    msg[2] = 0x1a;
+    cec_ll_tx(msg, 3);
+}
+
+void cec_menu_status_smp(int dest, int status)
+{
+    unsigned char msg[3];
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+
+    msg[0] = ((index & 0xf) << 4) | dest;
+    msg[1] = CEC_OC_MENU_STATUS;
+    if (status == DEVICE_MENU_ACTIVE)
+        msg[2] = DEVICE_MENU_ACTIVE;
+    else
+        msg[2] = DEVICE_MENU_INACTIVE;
+    cec_ll_tx(msg, 3);
+}
+
+void cec_imageview_on_smp(void)
+{
+    unsigned char msg[2];
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_IMAGE_VIEW_ON;
+    cec_ll_tx(msg, 2);
+}
+
+void cec_get_menu_language_smp(void)
+{
+    unsigned char msg[2];
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_GET_MENU_LANGUAGE;
+
+    cec_ll_tx(msg, 2);
+}
+
+
+void cec_inactive_source(int dest)
+{
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+    unsigned char msg[4];
+    unsigned char phy_addr_ab, phy_addr_cd;
+
+    phy_addr_ab = (cec_dev->phy_addr >> 8) & 0xff;
+    phy_addr_cd = (cec_dev->phy_addr >> 0) & 0xff;
+    msg[0] = ((index & 0xf) << 4) | dest;
+    msg[1] = CEC_OC_INACTIVE_SOURCE;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+
+    cec_ll_tx(msg, 4);
+}
+
+void cec_set_osd_name(int dest)
+{
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+    unsigned char osd_len = strlen(cec_dev->cec_info.osd_name);
+    unsigned char msg[16];
+
+    if (0xf != dest) {
+        msg[0] = ((index & 0xf) << 4) | dest;
+        msg[1] = CEC_OC_SET_OSD_NAME;
+        memcpy(&msg[2], cec_dev->cec_info.osd_name, osd_len);
+
+        cec_ll_tx(msg, 2 + osd_len);
+    }
+}
+
+void cec_active_source_smp(void)
+{
+    unsigned char msg[4];
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+    unsigned char phy_addr_ab;
+    unsigned char phy_addr_cd;
+
+    phy_addr_ab = (cec_dev->phy_addr >> 8) & 0xff;
+    phy_addr_cd = (cec_dev->phy_addr >> 0) & 0xff;
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_ACTIVE_SOURCE;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+    cec_ll_tx(msg, 4);
+}
+
+void cec_set_stream_path(unsigned char *msg)
+{
+    unsigned int phy_addr_active;
+
+    phy_addr_active = (unsigned int)(msg[2] << 8 | msg[3]);
+    if (phy_addr_active == cec_dev->phy_addr) {
+        cec_active_source_smp();
+        /*
+         * some types of TV such as panasonic need to send menu status,
+         * otherwise it will not send remote key event to control
+         * device's menu
+         */
+        cec_menu_status_smp(msg[0] >> 4, DEVICE_MENU_ACTIVE);
+    }
+}
+
+void cec_report_power_status(int dest, int status)
+{
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+    unsigned char msg[3];
+
+    msg[0] = ((index & 0xf) << 4) | dest;
+    msg[1] = CEC_OC_REPORT_POWER_STATUS;
+    msg[2] = status;
+    cec_ll_tx(msg, 3);
+}
+
+void cec_send_simplink_alive(void)
+{
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+    unsigned char msg[4];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_VENDOR_COMMAND;
+    msg[2] = 0x2;
+    msg[3] = 0x5;
+
+    cec_ll_tx(msg, 4);
+}
+
+void cec_send_simplink_ack(void)
+{
+    unsigned char index = cec_dev->cec_info.log_addr[0];
+    unsigned char msg[4];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_VENDOR_COMMAND;
+    msg[2] = 0x5;
+    msg[3] = 0x1;
+
+    cec_ll_tx(msg, 4);
+}
+
+int cec_node_init(struct hdmitx_dev *hdmitx_device)
+{
+    unsigned char a, b, c, d;
+
+    int i, bool = 0;
+    int phy_addr_ok = 1;
+    const enum _cec_log_dev_addr_e player_dev[3] = {
+        CEC_RECORDING_DEVICE_1_ADDR,
+        CEC_RECORDING_DEVICE_2_ADDR,
+        CEC_RECORDING_DEVICE_3_ADDR,
+    };
+
+    unsigned long cec_phy_addr;
+
+    /* If no connect, return directly */
+    if ((hdmitx_device->cec_init_ready == 0) ||
+        (hdmitx_device->hpd_state == 0)) {
+        return -1;
+    }
+    a = hdmitx_device->hdmi_info.vsdb_phy_addr.a;
+    b = hdmitx_device->hdmi_info.vsdb_phy_addr.b;
+    c = hdmitx_device->hdmi_info.vsdb_phy_addr.c;
+    d = hdmitx_device->hdmi_info.vsdb_phy_addr.d;
+
+    /* Don't init if switched to libcec mode*/
+    if ((cec_dev->hal_flag & (1 << HDMI_OPTION_SYSTEM_CEC_CONTROL)))
+        return -1;
+
+    CEC_INFO("cec_node_init started\n");
+
+    cec_phy_addr = ((a << 12) | (b << 8) | (c << 4) | (d << 0));
+
+    for (i = 0; i < 3; i++) {
+        CEC_INFO("CEC: start poll dev\n");
+        cec_polling_online_dev(player_dev[i], &bool);
+        CEC_INFO("player_dev[%d]:0x%x\n", i, player_dev[i]);
+        if (bool == 0) {   /* 0 means that no any respond */
+    /* If VSDB is not valid, use last or default physical address. */
+            cec_logicaddr_set(player_dev[i], CEC_LOGICAL_ADDR0);
+            if (hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0) {
+                phy_addr_ok = 0;
+                CEC_INFO("invalid cec PhyAddr\n");
+                if (cec_phyaddr_config(0, 0)) {
+                    CEC_INFO("use last physical address\n");
+                } else {
+                    cec_phyaddr_config(0x2000, 1);
+                    CEC_INFO("use Def Phy address\n");
+                }
+            } else
+                cec_phyaddr_config(cec_phy_addr, 1);
+
+                CEC_INFO("physical address:0x%x\n",
+                        cec_phyaddr_config(0, 0));
+
+                cec_dev->cec_info.power_status = TRANS_STANDBY_TO_ON;
+                cec_logicaddr_config(player_dev[i], 1);
+                cec_dev->cec_info.log_addr[0] = player_dev[i];
+                /* Set Physical address */
+                cec_dev->phy_addr = cec_phy_addr;
+
+                cec_dev->cec_info.cec_version = CEC_VERSION_14A;
+                cec_dev->cec_info.vendor_id = cec_dev->v_data.vendor_id;
+                strcpy(cec_dev->cec_info.osd_name,
+                       cec_dev->v_data.cec_osd_string);
+                cec_logicaddr_set(player_dev[i], CEC_LOGICAL_ADDR0);
+
+                CEC_INFO("Set logical address: %d\n",
+                    player_dev[i]);
+
+                cec_dev->cec_info.power_status = POWER_ON;
+                if (cec_dev->cec_info.menu_status == DEVICE_MENU_INACTIVE)
+                    break;
+                msleep(100);
+                if (phy_addr_ok) {
+                    cec_report_physical_address_smp();
+                    msleep(150);
+                }
+                cec_device_vendor_id();
+                cec_set_osd_name(0);
+
+                /* Disable switch TV on automatically */
+                if (!(hdmitx_device->cec_func_config &
+                     (1 << AUTO_POWER_ON_MASK))) {
+                    CEC_INFO("Auto TV switch on disabled\n");
+                    break;
+                }
+
+                cec_active_source_smp();
+                cec_imageview_on_smp();
+
+                cec_menu_status_smp(CEC_TV_ADDR, DEVICE_MENU_ACTIVE);
+
+                msleep(100);
+                cec_get_menu_language_smp();
+                cec_dev->cec_info.menu_status = DEVICE_MENU_ACTIVE;
+            break;
+        }
+    }
+    if (bool == 1) {
+        CEC_INFO("Can't get a valid logical address\n");
+        return -1;
+    } else {
+        CEC_INFO("cec node init: cec features ok !\n");
+        return 0;
+    }
+}
+
+static void cec_rx_process(void)
+{
+    int len = rx_len;
+    int initiator, follower;
+    int opcode;
+    unsigned char msg[MAX_MSG] = {};
+
+    if (len < 2 || !new_msg)        /* ignore ping message */
+        return;
+
+    memcpy(msg, rx_msg, len);
+    initiator = ((msg[0] >> 4) & 0xf);
+    follower  = msg[0] & 0xf;
+    if (follower != 0xf && follower != cec_dev->cec_info.log_addr[0]) {
+        CEC_ERR("wrong rx message of bad follower:%x", follower);
+        return;
+    }
+    opcode = msg[1];
+    switch (opcode) {
+    case CEC_OC_GET_CEC_VERSION:
+        cec_give_version(initiator);
+        break;
+
+    case CEC_OC_GIVE_DECK_STATUS:
+        cec_give_deck_status(initiator);
+        break;
+
+    case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+        cec_report_physical_address_smp();
+        break;
+
+    case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+        cec_device_vendor_id();
+        break;
+
+    case CEC_OC_GIVE_OSD_NAME:
+        cec_set_osd_name(initiator);
+        break;
+
+    case CEC_OC_STANDBY:
+        cec_inactive_source(initiator);
+        cec_menu_status_smp(initiator, DEVICE_MENU_INACTIVE);
+        break;
+
+    case CEC_OC_SET_STREAM_PATH:
+        cec_set_stream_path(msg);
+        /* wake up if in early suspend */
+        if (cec_dev->cec_suspend == CEC_EARLY_SUSPEND)
+            cec_key_report(0);
+        break;
+
+    case CEC_OC_REQUEST_ACTIVE_SOURCE:
+        if (!cec_dev->cec_suspend)
+            cec_active_source_smp();
+        break;
+
+    case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+        if (cec_dev->cec_suspend)
+            cec_report_power_status(initiator, POWER_STANDBY);
+        else
+            cec_report_power_status(initiator, POWER_ON);
+        break;
+
+
+    case CEC_OC_USER_CONTROL_RELEASED:
+        cec_user_control_released_irq();
+        break;
+
+    case CEC_OC_USER_CONTROL_PRESSED:
+        if (len < 3)
+            break;
+        cec_user_control_pressed_irq(msg[2]);
+        /* wake up by key function */
+        if (cec_dev->cec_suspend == CEC_EARLY_SUSPEND) {
+            if (msg[2] == 0x40 || msg[2] == 0x6d)
+                cec_key_report(0);
+        }
+        break;
+
+    case CEC_OC_PLAY:
+        if (len < 3)
+            break;
+        switch (msg[2]) {
+        case 0x24:
+            input_event(cec_dev->cec_info.remote_cec_dev,
+                EV_KEY, KEY_PLAYPAUSE, 1);
+            input_sync(cec_dev->cec_info.remote_cec_dev);
+            input_event(cec_dev->cec_info.remote_cec_dev,
+                EV_KEY, KEY_PLAYPAUSE, 0);
+            input_sync(cec_dev->cec_info.remote_cec_dev);
+            break;
+        case 0x25:
+            input_event(cec_dev->cec_info.remote_cec_dev,
+                EV_KEY, KEY_PLAYPAUSE, 1);
+            input_sync(cec_dev->cec_info.remote_cec_dev);
+            input_event(cec_dev->cec_info.remote_cec_dev,
+                EV_KEY, KEY_PLAYPAUSE, 0);
+            input_sync(cec_dev->cec_info.remote_cec_dev);
+            break;
+        default:
+            break;
+        }
+        break;
+
+    case CEC_OC_DECK_CONTROL:
+        if (len < 3)
+            break;
+        switch (msg[2]) {
+        case 0x3:
+            input_event(cec_dev->cec_info.remote_cec_dev,
+                EV_KEY, KEY_STOP, 1);
+            input_sync(cec_dev->cec_info.remote_cec_dev);
+            input_event(cec_dev->cec_info.remote_cec_dev,
+                EV_KEY, KEY_STOP, 0);
+            input_sync(cec_dev->cec_info.remote_cec_dev);
+            break;
+        default:
+            break;
+        }
+        break;
+
+    case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+        if (len < 3)
+            break;
+        switch(msg[2]){
+            //samsung vendor keys
+            case 0x91:
+                input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_EXIT, 1);
+                input_sync(cec_dev->cec_info.remote_cec_dev);
+                input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_EXIT, 0);
+                input_sync(cec_dev->cec_info.remote_cec_dev);
+                break;
+            case 0x96:
+                input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_LIST, 1);
+                input_sync(cec_dev->cec_info.remote_cec_dev);
+                input_event(cec_dev->cec_info.remote_cec_dev, EV_KEY, KEY_LIST, 0);
+                input_sync(cec_dev->cec_info.remote_cec_dev);
+                break;
+            default:
+                break;
+        }
+        break;
+    case CEC_OC_MENU_REQUEST:
+        if (cec_dev->cec_suspend)
+            cec_menu_status_smp(initiator, DEVICE_MENU_INACTIVE);
+        else
+            cec_menu_status_smp(initiator, DEVICE_MENU_ACTIVE);
+        break;
+    case CEC_OC_VENDOR_COMMAND:
+        if (len < 3)
+            break;
+        if (msg[2] == 0x1) {
+            cec_report_power_status(initiator, cec_dev->cec_info.power_status);
+            cec_send_simplink_alive();
+        } else if (msg[2] == 0x4) {
+            cec_send_simplink_ack();
+        }
+        break;
+	case CEC_OC_DEVICE_VENDOR_ID:
+		break;
+
+    default:
+        break;
+    }
+    new_msg = 0;
+}
+
+static void cec_task(struct work_struct *work)
+{
+    struct delayed_work *dwork;
+    int ret;
+
+    dwork = &cec_dev->cec_work;
+    if (cec_dev &&
+       !(cec_dev->hal_flag & (1 << HDMI_OPTION_SYSTEM_CEC_CONTROL))) {
+        if (1 << cec_dev->cec_info.log_addr[0] & (1 << 0x0 | 1 << 0xF)) {
+            ret = cec_node_init(cec_dev->tx_dev);
+            if (ret < 0) {
+                return;
+            }
+        }
+        cec_rx_process();
+    }
+    if (!cec_late_check_rx_buffer())
+        queue_delayed_work(cec_dev->cec_thread, dwork, CEC_FRAME_DELAY);
+}
+
+irqreturn_t cec_isr_handler(int irq, void *dev_instance)
+{
+    unsigned int intr_stat = 0;
+    struct delayed_work *dwork;
+
+    dwork = &cec_dev->cec_work;
+    intr_stat = cec_intr_stat();
+    if (intr_stat & (1<<1)) {   /* aocec tx intr */
+        tx_irq_handle();
+        return IRQ_HANDLED;
+    }
+    if ((-1) == cec_ll_rx(rx_msg, &rx_len))
+        return IRQ_HANDLED;
+
+    complete(&cec_dev->rx_ok);
+    /* check rx buffer is full */
+    new_msg = 1;
+    mod_delayed_work(cec_dev->cec_thread, dwork, 0);
+    return IRQ_HANDLED;
+}
+
+/******************** cec class interface *************************/
+static ssize_t device_type_show(struct class *cla,
+    struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%ld\n", cec_dev->dev_type);
+}
+
+static ssize_t device_type_store(struct class *cla,
+    struct class_attribute *attr, const char *buf, size_t count)
+{
+    unsigned long type;
+
+    if (sscanf(buf, "%ld", &type) != 1)
+        return -EINVAL;
+
+    cec_dev->dev_type = type;
+    CEC_ERR("set dev_type to %ld\n", type);
+    return count;
+}
+
+static ssize_t menu_language_show(struct class *cla,
+    struct class_attribute *attr, char *buf)
+{
+    char a, b, c;
+    a = ((cec_dev->cec_info.menu_lang >> 16) & 0xff);
+    b = ((cec_dev->cec_info.menu_lang >>  8) & 0xff);
+    c = ((cec_dev->cec_info.menu_lang >>  0) & 0xff);
+    return sprintf(buf, "%c%c%c\n", a, b, c);
+}
+
+static ssize_t menu_language_store(struct class *cla,
+    struct class_attribute *attr, const char *buf, size_t count)
+{
+    char a, b, c;
+
+    if (sscanf(buf, "%c%c%c", &a, &b, &c) != 3)
+        return -EINVAL;
+
+    cec_dev->cec_info.menu_lang = (a << 16) | (b << 8) | c;
+    CEC_ERR("set menu_language to %s\n", buf);
+    return count;
+}
+
+static ssize_t vendor_id_show(struct class *cla,
+    struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%x\n", cec_dev->cec_info.vendor_id);
+}
+
+static ssize_t vendor_id_store(struct class *cla, struct class_attribute *attr,
+    const char *buf, size_t count)
+{
+    int id;
+
+    if (sscanf(buf, "%x", &id) != 1)
+        return -EINVAL;
+    cec_dev->cec_info.vendor_id = id;
+    return count;
+}
+
+static ssize_t port_num_show(struct class *cla,
+    struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", cec_dev->port_num);
+}
+
+static ssize_t arc_port_show(struct class *cla,
+    struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%x\n", cec_dev->arc_port);
+}
+
+static ssize_t osd_name_show(struct class *cla,
+    struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n", cec_dev->cec_info.osd_name);
+}
+
+static ssize_t port_seq_show(struct class *cla,
+    struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%x\n", cec_dev->port_seq);
+}
+
+static ssize_t port_status_show(struct class *cla,
+    struct class_attribute *attr, char *buf)
+{
+    unsigned int tmp = 0;
+
+    if (cec_dev->dev_type == DEV_TYPE_TX) {
+        tmp = cec_dev->tx_dev->hpd_state;
+        return sprintf(buf, "%x\n", tmp);
+    }
+     else {
+#ifdef CONFIG_TVIN_HDMI
+        tmp = hdmirx_rd_top(TOP_HPD_PWR5V);
+        CEC_INFO("TOP_HPD_PWR5V:%x\n", tmp);
+        tmp >>= 20;
+        tmp &= 0xf;
+#endif
+        return sprintf(buf, "%x\n", tmp);
+    }
+}
+
+static ssize_t physical_addr_show(struct class *cla,
+    struct class_attribute *attr, char *buf)
+{
+    unsigned int tmp = cec_dev->phy_addr;
+
+    return sprintf(buf, "%04x\n", tmp);
+}
+
+static ssize_t physical_addr_store(struct class *cla,
+    struct class_attribute *attr,
+    const char *buf, size_t count)
+{
+    int addr;
+
+    if (sscanf(buf, "%x", &addr) != 1)
+        return -EINVAL;
+
+    if (addr > 0xffff || addr < 0) {
+        CEC_ERR("invalid input:%s\n", buf);
+        phy_addr_test = 0;
+        return -EINVAL;
+    }
+    cec_dev->phy_addr = addr;
+    phy_addr_test = 1;
+    return count;
+}
+
+static ssize_t dbg_en_show(struct class *cla,
+    struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%x\n", cec_msg_dbg_en);
+}
+
+static ssize_t dbg_en_store(struct class *cla, struct class_attribute *attr,
+    const char *buf, size_t count)
+{
+    int en;
+
+    if (sscanf(buf, "%d", &en) != 1)
+        return -EINVAL;
+
+    cec_msg_dbg_en = en ? 1 : 0;
+    return count;
+}
+
+static struct class_attribute aocec_class_attr[] = {
+    __ATTR_RO(port_num),
+    __ATTR_RO(port_seq),
+    __ATTR_RO(osd_name),
+    __ATTR_RO(port_status),
+    __ATTR_RO(arc_port),
+    __ATTR(physical_addr, 0664, physical_addr_show, physical_addr_store),
+    __ATTR(vendor_id, 0664, vendor_id_show, vendor_id_store),
+    __ATTR(menu_language, 0664, menu_language_show, menu_language_store),
+    __ATTR(device_type, 0664, device_type_show, device_type_store),
+    __ATTR(dbg_en, 0664, dbg_en_show, dbg_en_store),
+    __ATTR_NULL
+};
+
+/******************** cec hal interface ***************************/
+static int hdmitx_cec_open(struct inode *inode, struct file *file)
+{
+    cec_dev->cec_info.open_count++;
+    if (cec_dev->cec_info.open_count) {
+        cec_dev->cec_info.hal_ctl = 1;
+        /* enable all cec features */
+        cec_config(0x2f, 1);
+    }
+    return 0;
+}
+
+static int hdmitx_cec_release(struct inode *inode, struct file *file)
+{
+    cec_dev->cec_info.open_count--;
+    if (!cec_dev->cec_info.open_count) {
+        cec_dev->cec_info.hal_ctl = 0;
+        /* disable all cec features */
+        cec_config(0x0, 1);
+    }
+    return 0;
+}
+
+static ssize_t hdmitx_cec_read(struct file *f, char __user *buf,
+               size_t size, loff_t *p)
+{
+    int ret;
+
+    if ((cec_dev->hal_flag & (1 << HDMI_OPTION_SYSTEM_CEC_CONTROL)))
+        rx_len = 0;
+    ret = wait_for_completion_timeout(&cec_dev->rx_ok, CEC_FRAME_DELAY);
+    if (ret <= 0)
+        return ret;
+    if (rx_len == 0)
+        return 0;
+
+    if (copy_to_user(buf, rx_msg, rx_len))
+        return -EINVAL;
+    CEC_INFO("RX len: %d\n", rx_len);
+    return rx_len;
+}
+
+static ssize_t hdmitx_cec_write(struct file *f, const char __user *buf,
+                size_t size, loff_t *p)
+{
+    unsigned char tempbuf[16] = {};
+    int ret;
+
+    if (size > 16)
+        size = 16;
+    if (size <= 0)
+        return 0;
+
+    if (copy_from_user(tempbuf, buf, size))
+        return -EINVAL;
+
+    ret = cec_ll_tx(tempbuf, size);
+    /* delay a byte for continue message send */
+    msleep(25);
+    if (ret == CEC_FAIL_NACK) {
+        return -1;
+    }
+    else {
+        return size;
+    }
+}
+
+static void init_cec_port_info(struct hdmi_port_info *port,
+                   struct ao_cec_dev *cec_dev)
+{
+    unsigned int a, b, c;
+
+    b = cec_dev->port_num;
+    for (a = 0; a < b; a++) {
+        port[a].type = HDMI_INPUT;
+        port[a].port_id = a + 1;
+        port[a].cec_supported = 1;
+        /* set ARC feature according mask */
+        if (cec_dev->arc_port & (1 << a))
+            port[a].arc_supported = 1;
+        else
+            port[a].arc_supported = 0;
+
+        /* set port physical address according port sequence */
+        if (cec_dev->port_seq) {
+            c = (cec_dev->port_seq >> (4 * a)) & 0xf;
+            port[a].physical_address = (c + 1) * 0x1000;
+        } else {
+            /* asending order if port_seq is not set */
+            port[a].physical_address = (a + 1) * 0x1000;
+        }
+    }
+}
+
+static long hdmitx_cec_ioctl(struct file *f,
+                 unsigned int cmd, unsigned long arg)
+{
+    void __user *argp = (void __user *)arg;
+    unsigned long tmp;
+    struct hdmi_port_info *port;
+    int a, b, c, d;
+
+    switch (cmd) {
+    case CEC_IOC_GET_PHYSICAL_ADDR:
+        if (cec_dev->dev_type ==  DEV_TYPE_TX && !phy_addr_test) {
+            /* physical address for mbox */
+            if (cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.valid == 0)
+                return -EINVAL;
+            a = cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.a;
+            b = cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.b;
+            c = cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.c;
+            d = cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.d;
+            tmp = ((a << 12) | (b << 8) | (c << 4) | (d << 0));
+        } else {
+            /* physical address for TV */
+            tmp = 0;
+        }
+        if (!phy_addr_test) {
+            cec_dev->phy_addr = tmp;
+            cec_phyaddr_config(tmp, 1);
+        } else
+            tmp = cec_dev->phy_addr;
+
+        if (copy_to_user(argp, &tmp, _IOC_SIZE(cmd)))
+            return -EINVAL;
+        break;
+
+    case CEC_IOC_GET_VERSION:
+        tmp = CEC_VERSION_14A;
+        if (copy_to_user(argp, &tmp, _IOC_SIZE(cmd)))
+            return -EINVAL;
+        break;
+
+    case CEC_IOC_GET_VENDOR_ID:
+        tmp = cec_dev->v_data.vendor_id;
+        if (copy_to_user(argp, &tmp, _IOC_SIZE(cmd)))
+            return -EINVAL;
+        break;
+
+    case CEC_IOC_GET_PORT_NUM:
+        tmp = cec_dev->port_num;
+        if (copy_to_user(argp, &tmp, _IOC_SIZE(cmd)))
+            return -EINVAL;
+        break;
+
+    case CEC_IOC_GET_PORT_INFO:
+        port = kzalloc(sizeof(*port) * cec_dev->port_num, GFP_KERNEL);
+        if (!port) {
+            CEC_ERR("no memory\n");
+            return -EINVAL;
+        }
+        if (cec_dev->dev_type == DEV_TYPE_TX) {
+            /* for tx only 1 port */
+            a = cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.a;
+            b = cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.b;
+            c = cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.c;
+            d = cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.d;
+            tmp = ((a << 12) | (b << 8) | (c << 4) | (d << 0));
+            if (cec_dev->tx_dev->hdmi_info.vsdb_phy_addr.valid == 0)
+                tmp = 0xffff;
+            port->type = HDMI_OUTPUT;
+            port->port_id = 1;
+            port->cec_supported = 1;
+            /* not support arc for tx */
+            port->arc_supported = 0;
+            port->physical_address = tmp & 0xffff;
+            if (copy_to_user(argp, port, sizeof(*port))) {
+                kfree(port);
+                return -EINVAL;
+            }
+        } else {
+            b = cec_dev->port_num;
+            init_cec_port_info(port, cec_dev);
+            if (copy_to_user(argp, port, sizeof(*port) * b)) {
+                kfree(port);
+                return -EINVAL;
+            }
+        }
+        kfree(port);
+        break;
+
+    case CEC_IOC_SET_OPTION_WAKEUP:
+        /* TODO: */
+        break;
+
+    case CEC_IOC_SET_OPTION_ENALBE_CEC:
+        tmp = (1 << HDMI_OPTION_ENABLE_CEC);
+        if (arg) {
+            cec_dev->hal_flag |= tmp;
+            cec_pre_init();
+        } else {
+            cec_dev->hal_flag &= ~(tmp);
+            CEC_INFO("disable CEC\n");
+            cec_keep_reset();
+        }
+        break;
+
+    case CEC_IOC_SET_OPTION_SYS_CTRL:
+        tmp = (1 << HDMI_OPTION_SYSTEM_CEC_CONTROL);
+        if (arg)
+            cec_dev->hal_flag |= tmp;
+        else
+            cec_dev->hal_flag &= ~(tmp);
+        break;
+
+    case CEC_IOC_SET_OPTION_SET_LANG:
+        cec_dev->cec_info.menu_lang = arg;
+        break;
+
+    case CEC_IOC_GET_CONNECT_STATUS:
+        if (cec_dev->dev_type == DEV_TYPE_TX)
+            tmp = cec_dev->tx_dev->hpd_state;
+    #ifdef CONFIG_TVIN_HDMI
+        else {
+            if (copy_from_user(&a, argp, _IOC_SIZE(cmd)))
+                return -EINVAL;
+            tmp = (hdmirx_rd_top(TOP_HPD_PWR5V) >> 20);
+            if (tmp & (1 << (a - 1)))
+                tmp = 1;
+            else
+                tmp = 0;
+        }
+    #endif
+        if (copy_to_user(argp, &tmp, _IOC_SIZE(cmd)))
+            return -EINVAL;
+        break;
+
+    case CEC_IOC_ADD_LOGICAL_ADDR:
+        tmp = arg & 0xf;
+        CEC_INFO("CEC LA ARG:%ld", arg);
+        cec_logicaddr_set(tmp, CEC_LOGICAL_ADDR0);
+        cec_dev->cec_info.log_addr[0] = tmp;
+        /* TODO set multiple LA's. Does not work yet
+         * cec_logicaddr_setByMask(tmp);
+        */
+        /* add by hal, to init some data structure */
+        cec_dev->cec_info.power_status = POWER_ON;
+        cec_logicaddr_config(tmp, 1);
+
+        cec_dev->cec_info.cec_version = CEC_VERSION_14A;
+        cec_dev->cec_info.vendor_id = cec_dev->v_data.vendor_id;
+        strcpy(cec_dev->cec_info.osd_name,
+               cec_dev->v_data.cec_osd_string);
+
+        if (cec_dev->dev_type == DEV_TYPE_TX)
+            cec_dev->cec_info.menu_status = DEVICE_MENU_ACTIVE;
+        break;
+
+    case CEC_IOC_CLR_LOGICAL_ADDR:
+        cec_logicaddr_clear();
+        break;
+
+    case CEC_IOC_SET_DEV_TYPE:
+        if (arg != DEV_TYPE_TX && arg != DEV_TYPE_RX)
+            return -EINVAL;
+        cec_dev->dev_type = arg;
+        break;
+
+    case CEC_IOC_SET_ARC_ENABLE:
+    #ifdef CONFIG_TVIN_HDMI
+        /* select arc according arg */
+        if (arg)
+            hdmirx_wr_top(TOP_ARCTX_CNTL, 0x03);
+        else
+            hdmirx_wr_top(TOP_ARCTX_CNTL, 0x00);
+        CEC_INFO("set arc en:%ld, reg:%lx\n",
+             arg, hdmirx_rd_top(TOP_ARCTX_CNTL));
+    #endif
+        break;
+
+    default:
+        break;
+    }
+    return 0;
+}
+
+#ifdef CONFIG_COMPAT
+static long hdmitx_cec_compat_ioctl(struct file *f,
+                    unsigned int cmd, unsigned long arg)
+{
+    arg = (unsigned long)compat_ptr(arg);
+    return hdmitx_cec_ioctl(f, cmd, arg);
+}
+#endif
+
+/* for improve rw permission */
+static char *aml_cec_class_devnode(struct device *dev, umode_t *mode)
+{
+    if (mode)
+        *mode = 0666;
+    CEC_INFO("mode is %x\n", *mode);
+    return NULL;
+}
+
+static struct class aocec_class = {
+    .name = CEC_DEV_NAME,
+    .class_attrs = aocec_class_attr,
+    .devnode = aml_cec_class_devnode,
+};
+
+
+static const struct file_operations hdmitx_cec_fops = {
+    .owner          = THIS_MODULE,
+    .open           = hdmitx_cec_open,
+    .read           = hdmitx_cec_read,
+    .write          = hdmitx_cec_write,
+    .release        = hdmitx_cec_release,
+    .unlocked_ioctl = hdmitx_cec_ioctl,
+#ifdef CONFIG_COMPAT
+    .compat_ioctl   = hdmitx_cec_compat_ioctl,
+#endif
+};
+
+/************************ cec high level code *****************************/
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void aocec_early_suspend(struct early_suspend *h)
+{
+    cec_dev->cec_suspend = CEC_EARLY_SUSPEND;
+    CEC_INFO("%s, suspend:%d\n", __func__, cec_dev->cec_suspend);
+}
+
+static void aocec_late_resume(struct early_suspend *h)
+{
+    cec_dev->cec_suspend = 0;
+    CEC_INFO("%s, suspend:%d\n", __func__, cec_dev->cec_suspend);
+
+}
+#endif
+
+static int aml_cec_probe(struct platform_device *pdev)
+{
+    int i;
+    struct device *cdev;
+#ifdef CONFIG_OF
+    struct device_node *node = pdev->dev.of_node;
+    int irq_idx = 0, r;
+    const char *pin_name = NULL, *irq_name = NULL;
+    struct pinctrl *p;
+    struct vendor_info_data *vend;
+    struct resource *res;
+    resource_size_t *base;
+#endif
+
+    cec_dev = kzalloc(sizeof(struct ao_cec_dev), GFP_KERNEL);
+    if (!cec_dev) {
+        CEC_ERR("alloc memory failed\n");
+        return -ENOMEM;
+    }
+    cec_dev->dev_type = DEV_TYPE_TX;
+    cec_dev->dbg_dev  = &pdev->dev;
+    cec_dev->tx_dev   = get_hdmitx_device();
+    phy_addr_test = 0;
+
+    /* cdev registe */
+    r = class_register(&aocec_class);
+    if (r) {
+        CEC_ERR("regist class failed\n");
+        return -EINVAL;
+    }
+    pdev->dev.class = &aocec_class;
+    cec_dev->cec_info.dev_no = register_chrdev(0, CEC_DEV_NAME,
+                      &hdmitx_cec_fops);
+    if (cec_dev->cec_info.dev_no < 0) {
+        CEC_ERR("alloc chrdev failed\n");
+        return -EINVAL;
+    }
+    CEC_INFO("alloc chrdev %x\n", cec_dev->cec_info.dev_no);
+    cdev = device_create(&aocec_class, &pdev->dev,
+                 MKDEV(cec_dev->cec_info.dev_no, 0),
+                 NULL, CEC_DEV_NAME);
+    if (IS_ERR(cdev)) {
+        CEC_ERR("create chrdev failed, dev:%p\n", cdev);
+        unregister_chrdev(cec_dev->cec_info.dev_no,
+                  CEC_DEV_NAME);
+        return -EINVAL;
+    }
+
+    init_completion(&cec_dev->rx_ok);
+    init_completion(&cec_dev->tx_ok);
+    mutex_init(&cec_dev->cec_mutex);
+    spin_lock_init(&cec_dev->cec_reg_lock);
+    cec_dev->cec_thread = create_workqueue("cec_work");
+    if (cec_dev->cec_thread == NULL) {
+        CEC_INFO("create work queue failed\n");
+        return -EFAULT;
+    }
+    INIT_DELAYED_WORK(&cec_dev->cec_work, cec_task);
+    hrtimer_init(&cec_key_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    cec_key_timer.function = cec_key_up;
+    cec_dev->cec_info.remote_cec_dev = input_allocate_device();
+    if (!cec_dev->cec_info.remote_cec_dev)
+        CEC_INFO("No enough memory\n");
+
+    cec_dev->cec_info.remote_cec_dev->name = "cec_input";
+
+    cec_dev->cec_info.remote_cec_dev->evbit[0] = BIT_MASK(EV_KEY);
+    cec_dev->cec_info.remote_cec_dev->keybit[BIT_WORD(BTN_0)] =
+        BIT_MASK(BTN_0);
+    cec_dev->cec_info.remote_cec_dev->id.bustype = BUS_ISA;
+    cec_dev->cec_info.remote_cec_dev->id.vendor = 0x1b8e;
+    cec_dev->cec_info.remote_cec_dev->id.product = 0x0cec;
+    cec_dev->cec_info.remote_cec_dev->id.version = 0x0001;
+
+    for (i = 0; i < 160; i++)
+        set_bit(cec_key_map[i], cec_dev->cec_info.remote_cec_dev->keybit);
+    if (input_register_device(cec_dev->cec_info.remote_cec_dev)) {
+        CEC_INFO("Failed to register device\n");
+        input_free_device(cec_dev->cec_info.remote_cec_dev);
+    }
+
+#ifdef CONFIG_OF
+    /* pinmux set */
+    if (of_get_property(node, "pinctrl-names", NULL)) {
+        r = of_property_read_string(node,
+                        "pinctrl-names",
+                        &pin_name);
+        if (!r)
+            p = devm_pinctrl_get_select(&pdev->dev, pin_name);
+    }
+
+    /* irq set */
+    irq_idx = of_irq_get(node, 0);
+    cec_dev->irq_cec = irq_idx;
+    if (of_get_property(node, "interrupt-names", NULL)) {
+        r = of_property_read_string(node, "interrupt-names", &irq_name);
+        if (!r) {
+            r = request_irq(irq_idx, &cec_isr_handler, IRQF_SHARED,
+                    irq_name, (void *)cec_dev);
+        }
+    }
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (res) {
+        base = ioremap(res->start, res->end - res->start);
+        cec_dev->exit_reg = (void *)base;
+    } else {
+        CEC_INFO("no memory resource\n");
+        cec_dev->exit_reg = NULL;
+    }
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+    if (res) {
+        base = ioremap(res->start, res->end - res->start);
+        cec_dev->cec_reg = (void *)base;
+    } else {
+        CEC_ERR("no CEC reg resource\n");
+        cec_dev->cec_reg = NULL;
+    }
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+    if (res) {
+        base = ioremap(res->start, res->end - res->start);
+        cec_dev->hdmi_rxreg = (void *)base;
+    } else {
+        CEC_ERR("no hdmirx reg resource\n");
+        cec_dev->hdmi_rxreg = NULL;
+    }
+
+    r = of_property_read_u32(node, "port_num", &(cec_dev->port_num));
+    if (r) {
+        CEC_ERR("not find 'port_num'\n");
+        cec_dev->port_num = 1;
+    }
+    r = of_property_read_u32(node, "arc_port_mask", &(cec_dev->arc_port));
+    if (r) {
+        CEC_ERR("not find 'arc_port_mask'\n");
+        cec_dev->arc_port = 0;
+    }
+
+    vend = &cec_dev->v_data;
+    r = of_property_read_string(node, "vendor_name",
+        (const char **)&(vend->vendor_name));
+    if (r)
+        CEC_INFO("not find vendor name\n");
+
+    r = of_property_read_u32(node, "vendor_id", &(vend->vendor_id));
+    if (r)
+        CEC_INFO("not find vendor id\n");
+
+    r = of_property_read_string(node, "product_desc",
+        (const char **)&(vend->product_desc));
+    if (r)
+        CEC_INFO("not find product desc\n");
+
+    r = of_property_read_string(node, "cec_osd_string",
+        (const char **)&(vend->cec_osd_string));
+    if (r) {
+        CEC_INFO("not find cec osd string\n");
+        strcpy(vend->cec_osd_string, "AML TV/BOX");
+    }
+
+    /* get port sequence */
+    node = of_find_node_by_path("/hdmirx");
+    if (node == NULL) {
+        CEC_ERR("can't find hdmirx\n");
+        cec_dev->port_seq = 0;
+    } else {
+        r = of_property_read_u32(node, "rx_port_maps",
+                     &(cec_dev->port_seq));
+        if (r)
+            CEC_INFO("not find rx_port_maps\n");
+    }
+#endif
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    aocec_suspend_handler.level   = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
+    aocec_suspend_handler.suspend = aocec_early_suspend;
+    aocec_suspend_handler.resume  = aocec_late_resume;
+    aocec_suspend_handler.param   = cec_dev;
+    register_early_suspend(&aocec_suspend_handler);
+#endif
+    /* for init */
+    cec_pre_init();
+    queue_delayed_work(cec_dev->cec_thread, &cec_dev->cec_work, 0);
+    cec_dev->tx_dev->cec_init_ready = 1;
+    return 0;
+}
+
+static int aml_cec_remove(struct platform_device *pdev)
+{
+    CEC_INFO("cec uninit!\n");
+    free_irq(cec_dev->irq_cec, (void *)cec_dev);
+    cec_dev->tx_dev->cec_init_ready = 0;
+
+    if (cec_dev->cec_thread) {
+        cancel_delayed_work_sync(&cec_dev->cec_work);
+        destroy_workqueue(cec_dev->cec_thread);
+    }
+    input_unregister_device(cec_dev->cec_info.remote_cec_dev);
+    unregister_chrdev(cec_dev->cec_info.dev_no, CEC_DEV_NAME);
+    class_unregister(&aocec_class);
+    kfree(cec_dev);
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int aml_cec_pm_prepare(struct device *dev)
+{
+    cec_dev->cec_suspend = CEC_DEEP_SUSPEND;
+    CEC_INFO("%s, cec_suspend:%d\n", __func__, cec_dev->cec_suspend);
+    return 0;
+}
+
+static void aml_cec_pm_complete(struct device *dev)
+{
+    int exit = 0;
+
+    if (cec_dev->exit_reg) {
+        exit = readl(cec_dev->exit_reg);
+        CEC_INFO("wake up flag:%x\n", exit);
+    }
+    if (((exit >> 28) & 0xf) == CEC_WAKEUP) {
+        cec_key_report(0);
+    }
+}
+
+static int aml_cec_resume_noirq(struct device *dev)
+{
+    CEC_INFO("cec resume noirq!\n");
+    cec_dev->cec_info.power_status = TRANS_STANDBY_TO_ON;
+    return 0;
+}
+
+static const struct dev_pm_ops aml_cec_pm = {
+    .prepare  = aml_cec_pm_prepare,
+    .complete = aml_cec_pm_complete,
+    .resume_noirq = aml_cec_resume_noirq,
+};
+#endif
+
+#ifdef CONFIG_OF
+static const struct of_device_id aml_cec_dt_match[] = {
+    {
+        .compatible = "amlogic, amlogic-aocec",
+    },
+    {},
+};
+#endif
+
+static struct platform_driver aml_cec_driver = {
+    .driver = {
+        .name  = "cectx",
+        .owner = THIS_MODULE,
+    #ifdef CONFIG_PM
+        .pm     = &aml_cec_pm,
+    #endif
+    #ifdef CONFIG_OF
+        .of_match_table = aml_cec_dt_match,
+    #endif
+    },
+    .probe  = aml_cec_probe,
+    .remove = aml_cec_remove,
+};
+
+static int __init cec_init(void)
+{
+    int ret;
+    ret = platform_driver_register(&aml_cec_driver);
+    return ret;
+}
+
+static void __exit cec_uninit(void)
+{
+    platform_driver_unregister(&aml_cec_driver);
+}
+
+
+module_init(cec_init);
+module_exit(cec_uninit);
+MODULE_DESCRIPTION("AMLOGIC HDMI TX CEC driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/cec/hdmi_ao_cec.h b/drivers/amlogic/cec/hdmi_ao_cec.h
new file mode 100644
index 0000000..965c2f9
--- /dev/null
+++ b/drivers/amlogic/cec/hdmi_ao_cec.h
@@ -0,0 +1,179 @@
+#ifndef __AO_CEC_H__
+#define __AO_CEC_H__
+
+#define AO_BASE				0xc8100000
+
+#define AO_CEC_GEN_CNTL			((0x40 << 2))
+#define AO_CEC_RW_REG			((0x41 << 2))
+#define AO_CEC_INTR_MASKN		((0x42 << 2))
+#define AO_CEC_INTR_CLR			((0x43 << 2))
+#define AO_CEC_INTR_STAT		((0x44 << 2))
+
+#define AO_CRT_CLK_CNTL1		((0x1a << 2))
+
+#define AO_DEBUG_REG0			((0x28 << 2))
+#define AO_DEBUG_REG1			((0x29 << 2))
+#define AO_DEBUG_REG2			((0x2a << 2))
+#define AO_DEBUG_REG3			((0x2b << 2))
+
+/* read/write */
+#define CEC_TX_MSG_0_HEADER        0x00
+#define CEC_TX_MSG_1_OPCODE        0x01
+#define CEC_TX_MSG_2_OP1           0x02
+#define CEC_TX_MSG_3_OP2           0x03
+#define CEC_TX_MSG_4_OP3           0x04
+#define CEC_TX_MSG_5_OP4           0x05
+#define CEC_TX_MSG_6_OP5           0x06
+#define CEC_TX_MSG_7_OP6           0x07
+#define CEC_TX_MSG_8_OP7           0x08
+#define CEC_TX_MSG_9_OP8           0x09
+#define CEC_TX_MSG_A_OP9           0x0A
+#define CEC_TX_MSG_B_OP10          0x0B
+#define CEC_TX_MSG_C_OP11          0x0C
+#define CEC_TX_MSG_D_OP12          0x0D
+#define CEC_TX_MSG_E_OP13          0x0E
+#define CEC_TX_MSG_F_OP14          0x0F
+
+/* read/write */
+#define CEC_TX_MSG_LENGTH          0x10
+#define CEC_TX_MSG_CMD             0x11
+#define CEC_TX_WRITE_BUF           0x12
+#define CEC_TX_CLEAR_BUF           0x13
+#define CEC_RX_MSG_CMD             0x14
+#define CEC_RX_CLEAR_BUF           0x15
+#define CEC_LOGICAL_ADDR0          0x16
+#define CEC_LOGICAL_ADDR1          0x17
+#define CEC_LOGICAL_ADDR2          0x18
+#define CEC_LOGICAL_ADDR3          0x19
+#define CEC_LOGICAL_ADDR4          0x1A
+#define CEC_CLOCK_DIV_H            0x1B
+#define CEC_CLOCK_DIV_L            0x1C
+
+/* The following registers are for fine tuning CEC bit timing parameters.
+ * They are only valid in AO CEC, NOT valid in HDMITX CEC.
+ * The AO CEC's timing parameters are already set default to work with
+ * 32768Hz clock, so hopefully SW never need to program these registers.
+ * The timing registers are made programmable just in case. */
+#define AO_CEC_QUIESCENT_25MS_BIT7_0            0x20
+#define AO_CEC_QUIESCENT_25MS_BIT11_8           0x21
+#define AO_CEC_STARTBITMINL2H_3MS5_BIT7_0       0x22
+#define AO_CEC_STARTBITMINL2H_3MS5_BIT8         0x23
+#define AO_CEC_STARTBITMAXL2H_3MS9_BIT7_0       0x24
+#define AO_CEC_STARTBITMAXL2H_3MS9_BIT8         0x25
+#define AO_CEC_STARTBITMINH_0MS6_BIT7_0         0x26
+#define AO_CEC_STARTBITMINH_0MS6_BIT8           0x27
+#define AO_CEC_STARTBITMAXH_1MS0_BIT7_0         0x28
+#define AO_CEC_STARTBITMAXH_1MS0_BIT8           0x29
+#define AO_CEC_STARTBITMINTOTAL_4MS3_BIT7_0     0x2A
+#define AO_CEC_STARTBITMINTOTAL_4MS3_BIT9_8     0x2B
+#define AO_CEC_STARTBITMAXTOTAL_4MS7_BIT7_0     0x2C
+#define AO_CEC_STARTBITMAXTOTAL_4MS7_BIT9_8     0x2D
+#define AO_CEC_LOGIC1MINL2H_0MS4_BIT7_0         0x2E
+#define AO_CEC_LOGIC1MINL2H_0MS4_BIT8           0x2F
+#define AO_CEC_LOGIC1MAXL2H_0MS8_BIT7_0         0x30
+#define AO_CEC_LOGIC1MAXL2H_0MS8_BIT8           0x31
+#define AO_CEC_LOGIC0MINL2H_1MS3_BIT7_0         0x32
+#define AO_CEC_LOGIC0MINL2H_1MS3_BIT8           0x33
+#define AO_CEC_LOGIC0MAXL2H_1MS7_BIT7_0         0x34
+#define AO_CEC_LOGIC0MAXL2H_1MS7_BIT8           0x35
+#define AO_CEC_LOGICMINTOTAL_2MS05_BIT7_0       0x36
+#define AO_CEC_LOGICMINTOTAL_2MS05_BIT9_8       0x37
+#define AO_CEC_LOGICMAXHIGH_2MS8_BIT7_0         0x38
+#define AO_CEC_LOGICMAXHIGH_2MS8_BIT8           0x39
+#define AO_CEC_LOGICERRLOW_3MS4_BIT7_0          0x3A
+#define AO_CEC_LOGICERRLOW_3MS4_BIT8            0x3B
+#define AO_CEC_NOMSMPPOINT_1MS05                0x3C
+#define AO_CEC_DELCNTR_LOGICERR                 0x3E
+#define AO_CEC_TXTIME_17MS_BIT7_0               0x40
+#define AO_CEC_TXTIME_17MS_BIT10_8              0x41
+#define AO_CEC_TXTIME_2BIT_BIT7_0               0x42
+#define AO_CEC_TXTIME_2BIT_BIT10_8              0x43
+#define AO_CEC_TXTIME_4BIT_BIT7_0               0x44
+#define AO_CEC_TXTIME_4BIT_BIT10_8              0x45
+#define AO_CEC_STARTBITNOML2H_3MS7_BIT7_0       0x46
+#define AO_CEC_STARTBITNOML2H_3MS7_BIT8         0x47
+#define AO_CEC_STARTBITNOMH_0MS8_BIT7_0         0x48
+#define AO_CEC_STARTBITNOMH_0MS8_BIT8           0x49
+#define AO_CEC_LOGIC1NOML2H_0MS6_BIT7_0         0x4A
+#define AO_CEC_LOGIC1NOML2H_0MS6_BIT8           0x4B
+#define AO_CEC_LOGIC0NOML2H_1MS5_BIT7_0         0x4C
+#define AO_CEC_LOGIC0NOML2H_1MS5_BIT8           0x4D
+#define AO_CEC_LOGIC1NOMH_1MS8_BIT7_0           0x4E
+#define AO_CEC_LOGIC1NOMH_1MS8_BIT8             0x4F
+#define AO_CEC_LOGIC0NOMH_0MS9_BIT7_0           0x50
+#define AO_CEC_LOGIC0NOMH_0MS9_BIT8             0x51
+#define AO_CEC_LOGICERRLOW_3MS6_BIT7_0          0x52
+#define AO_CEC_LOGICERRLOW_3MS6_BIT8            0x53
+#define AO_CEC_CHKCONTENTION_0MS1               0x54
+#define AO_CEC_PREPARENXTBIT_0MS05_BIT7_0       0x56
+#define AO_CEC_PREPARENXTBIT_0MS05_BIT8         0x57
+#define AO_CEC_NOMSMPACKPOINT_0MS45             0x58
+#define AO_CEC_ACK0NOML2H_1MS5_BIT7_0           0x5A
+#define AO_CEC_ACK0NOML2H_1MS5_BIT8             0x5B
+
+#define AO_CEC_BUGFIX_DISABLE_0                 0x60
+#define AO_CEC_BUGFIX_DISABLE_1                 0x61
+
+/* read only */
+#define CEC_RX_MSG_0_HEADER        0x80
+#define CEC_RX_MSG_1_OPCODE        0x81
+#define CEC_RX_MSG_2_OP1           0x82
+#define CEC_RX_MSG_3_OP2           0x83
+#define CEC_RX_MSG_4_OP3           0x84
+#define CEC_RX_MSG_5_OP4           0x85
+#define CEC_RX_MSG_6_OP5           0x86
+#define CEC_RX_MSG_7_OP6           0x87
+#define CEC_RX_MSG_8_OP7           0x88
+#define CEC_RX_MSG_9_OP8           0x89
+#define CEC_RX_MSG_A_OP9           0x8A
+#define CEC_RX_MSG_B_OP10          0x8B
+#define CEC_RX_MSG_C_OP11          0x8C
+#define CEC_RX_MSG_D_OP12          0x8D
+#define CEC_RX_MSG_E_OP13          0x8E
+#define CEC_RX_MSG_F_OP14          0x8F
+
+/* read only */
+#define CEC_RX_MSG_LENGTH          0x90
+#define CEC_RX_MSG_STATUS          0x91
+#define CEC_RX_NUM_MSG             0x92
+#define CEC_TX_MSG_STATUS          0x93
+#define CEC_TX_NUM_MSG             0x94
+
+/* tx_msg_cmd definition */
+#define TX_NO_OP                0  /* No transaction */
+#define TX_REQ_CURRENT          1  /* Transmit earliest message in buffer */
+#define TX_ABORT                2  /* Abort transmitting earliest message */
+/* Overwrite earliest message in buffer and transmit next message */
+#define TX_REQ_NEXT             3
+
+/* tx_msg_status definition */
+#define TX_IDLE                 0  /* No transaction */
+#define TX_BUSY                 1  /* Transmitter is busy */
+/* Message has been successfully transmitted */
+#define TX_DONE                 2
+#define TX_ERROR                3  /* Message has been transmitted with error */
+
+/* rx_msg_cmd */
+#define RX_NO_OP                0  /* No transaction */
+#define RX_ACK_CURRENT          1  /* Read earliest message in buffer */
+#define RX_DISABLE              2  /* Disable receiving latest message */
+/* Clear earliest message from buffer and read next message */
+#define RX_ACK_NEXT             3
+
+/* rx_msg_status */
+#define RX_IDLE                 0  /* No transaction */
+#define RX_BUSY                 1  /* Receiver is busy */
+#define RX_DONE                 2  /* Message has been received successfully */
+#define RX_ERROR                3  /* Message has been received with error */
+
+#ifdef CONFIG_TVIN_HDMI
+extern unsigned long hdmirx_rd_top(unsigned long addr);
+extern void hdmirx_wr_top(unsigned long addr, unsigned long data);
+#define TOP_HPD_PWR5V           0x002
+#define TOP_ARCTX_CNTL          0x010
+#endif
+
+unsigned int aocec_rd_reg(unsigned long addr);
+void aocec_wr_reg(unsigned long addr, unsigned long data);
+
+#endif	/* __AO_CEC_H__ */
diff --git a/drivers/amlogic/hdmi/Kconfig b/drivers/amlogic/hdmi/Kconfig
index 38b8ca4..1edf20a 100644
--- a/drivers/amlogic/hdmi/Kconfig
+++ b/drivers/amlogic/hdmi/Kconfig
@@ -34,4 +34,14 @@ config AML_HDMI_TX_HDCP
                 hdmitx hdcp enable, it should be enalbe if board burned hdmitx hdcp keys
 endif
 
+if AML_HDMI_TX_20
+if !AML_AO_CEC
+config AML_HDMI_TX_NEW_CEC_DRIVER
+        bool "HDMI new CEC driver"
+        default n
+        help
+                hdmitx uses new CEC driver
+endif
+endif
+
 endmenu
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/Makefile b/drivers/amlogic/hdmi/hdmi_tx_20/Makefile
index 95b7ae0..64132b8 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/Makefile
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/Makefile
@@ -1,8 +1,16 @@
 obj-$(CONFIG_AML_HDMI_TX_20)		+= hdmitx20.o
 
 hdmitx20-objs := hdmi_tx_main.o hdmi_tx_video.o hdmi_tx_audio.o hdmi_tx_edid.o \
-		 hdmi_tx_audio.o hdmi_tx_hdcp.o hdmi_tx_scdc.o hdmi_tx_cec.o \
-		 hdmi_cec_key.o
-obj-$(CONFIG_AML_HDMI_TX_20) += hw/ hdcp22/
+		 hdmi_tx_audio.o hdmi_tx_hdcp.o hdmi_tx_scdc.o 
+
+ifndef CONFIG_AML_AO_CEC
+ifdef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
+  hdmitx20-objs += amlogic_cec.o
+else
+  hdmitx20-objs += hdmi_cec_key.o hdmi_tx_cec.o
+endif
+endif
+
+obj-$(CONFIG_AML_HDMI_TX_20) += hw/
 
 #EXTRA_CFLAGS += -O2
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/amlogic_cec.c b/drivers/amlogic/hdmi/hdmi_tx_20/amlogic_cec.c
new file mode 100644
index 0000000..81d2fb9
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/amlogic_cec.c
@@ -0,0 +1,710 @@
+/* linux/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c
+ *
+ * Copyright (c) 2016 Gerald Dachs
+ *
+ * CEC interface file for Amlogic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/clk.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/cdev.h>
+#include <linux/list.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/atomic.h>
+#include <linux/semaphore.h>
+#include <linux/amlogic/tvin/tvin.h>
+#include <linux/pinctrl/consumer.h>
+
+/*
+ * #include <asm/uaccess.h>
+ * #include <asm/delay.h>
+ * #include <mach/gpio.h>
+ * #include <mach/am_regs.h>
+ * #include <mach/power_gate.h>
+ */
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include "hw/hdmi_tx_reg.h"
+#include "hw/mach_reg.h"
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+
+#define CONFIG_TV_DEBUG // for verbose output
+unsigned long amlogic_cec_debug_flag = 1;
+
+MODULE_AUTHOR("Gerald Dachs");
+MODULE_DESCRIPTION("Amlogic CEC driver");
+MODULE_LICENSE("GPL");
+
+//unused, only left to satisfy the linker
+bool cec_msg_dbg_en = 1;
+
+#define DRV_NAME "amlogic_cec"
+#ifndef amlogic_cec_log_dbg
+#define amlogic_cec_log_dbg(fmt, ...) \
+    if (amlogic_cec_debug_flag)       \
+printk(KERN_INFO "[%s] %s(): " fmt, DRV_NAME, __func__, ##__VA_ARGS__)
+#endif
+
+#define CEC_IOC_MAGIC        'c'
+#define CEC_IOC_SETLADDR     _IOW(CEC_IOC_MAGIC, 0, unsigned int)
+#define CEC_IOC_GETPADDR     _IO(CEC_IOC_MAGIC, 1)
+
+#define VERSION   "0.0.1" /* Driver version number */
+#define CEC_MINOR 243   /* Major 10, Minor 242, /dev/cec */
+//#define INT_AO_CEC 231 /* AO CEC IRQ */
+
+/* CEC Rx buffer size */
+#define CEC_RX_BUFF_SIZE            16
+/* CEC Tx buffer size */
+#define CEC_TX_BUFF_SIZE            16
+
+static DEFINE_SEMAPHORE(init_mutex);
+
+struct cec_rx_list {
+    u8 buffer[CEC_RX_BUFF_SIZE];
+    unsigned char size;
+    struct list_head list;
+};
+
+struct cec_rx_struct {
+    spinlock_t lock;
+    wait_queue_head_t waitq;
+    atomic_t state;
+    struct list_head list;
+};
+
+struct cec_tx_struct {
+    spinlock_t lock;
+    wait_queue_head_t waitq;
+    atomic_t state;
+};
+
+enum cec_state {
+    STATE_RX,
+    STATE_TX,
+    STATE_DONE,
+    STATE_ERROR
+};
+
+static char banner[] __initdata =
+"Amlogic CEC Driver, (c) 2016 Gerald Dachs";
+
+static struct cec_rx_struct cec_rx_struct;
+
+static struct cec_tx_struct cec_tx_struct;
+
+static atomic_t hdmi_on = ATOMIC_INIT(0);
+
+struct cec_global_info_t cec_global_info;
+
+static struct hdmitx_dev* hdmitx_device = NULL;
+
+static void amlogic_cec_set_rx_state(enum cec_state state)
+{
+    atomic_set(&cec_rx_struct.state, state);
+}
+
+static void amlogic_cec_set_tx_state(enum cec_state state)
+{
+    atomic_set(&cec_tx_struct.state, state);
+}
+
+static void amlogic_cec_msg_dump(char * msg_tag, const unsigned char *data, unsigned char count)
+{
+    int i;
+    int pos;
+    unsigned char msg_log_buf[128] = { 0 };
+
+    if (amlogic_cec_debug_flag == 1)
+    {
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "msg %s len: %d   dat: ", msg_tag, count);
+        for (i = 0; i < count; ++i)
+        {
+            pos += sprintf(msg_log_buf + pos, "%02x ", data[i]);
+        }
+        pos += sprintf(msg_log_buf + pos, "\n");
+        msg_log_buf[pos] = '\0';
+        amlogic_cec_log_dbg("CEC MSG dump: %s", msg_log_buf);
+    }
+}
+
+static unsigned int amlogic_cec_read_reg(unsigned int reg)
+{
+    return aocec_rd_reg(reg);
+}
+
+static void amlogic_cec_write_reg(unsigned int reg, unsigned int value)
+{
+    aocec_wr_reg(reg, value);
+}
+
+static int amlogic_cec_read_hw(unsigned char *data, unsigned char *count)
+{
+    int ret = -1;
+    int valid_msg;
+    int rx_msg_status;
+    int rx_num_msg;
+
+    rx_msg_status = amlogic_cec_read_reg(CEC_RX_MSG_STATUS);
+    rx_num_msg = amlogic_cec_read_reg(CEC_RX_NUM_MSG);
+
+    amlogic_cec_log_dbg("rx_msg_status: %d, rx_num_msg: %d\n", rx_msg_status, rx_num_msg);
+
+    valid_msg = (RX_DONE == rx_msg_status) && (1 == rx_num_msg);
+
+    if (valid_msg)
+    {
+        int i;
+
+        *count = amlogic_cec_read_reg(CEC_RX_MSG_LENGTH) + 1;
+        for (i = 0; i < (*count) && i < CEC_RX_BUFF_SIZE; ++i)
+        {
+            data[i]= amlogic_cec_read_reg(CEC_RX_MSG_0_HEADER + i);
+        }
+
+        amlogic_cec_msg_dump("RX", data, *count);
+
+        ret = RX_DONE;
+    }
+
+    hd_write_reg(P_AO_CEC_INTR_CLR, (1 << 2));
+    amlogic_cec_write_reg(CEC_RX_MSG_CMD, valid_msg ? RX_ACK_NEXT : RX_ACK_CURRENT);
+    amlogic_cec_write_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+
+    return ret;
+}
+
+static void amlogic_cec_write_hw(const char *data, size_t count)
+{
+    int i;
+
+    for (i = 0; i < count; ++i)
+    {
+        amlogic_cec_write_reg(CEC_TX_MSG_0_HEADER + i, data[i]);
+    }
+    amlogic_cec_write_reg(CEC_TX_MSG_LENGTH, count - 1);
+    amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_REQ_CURRENT);
+
+    amlogic_cec_msg_dump("TX", data, count);
+}
+
+unsigned short cec_log_addr_to_dev_type(unsigned char log_addr)
+{
+    // unused, just to satisfy the linker
+    return log_addr;
+}
+
+static int detect_tv_support_cec(unsigned addr)
+{
+    unsigned int ret = 0;
+    unsigned char msg[1];
+    cec_msg_dbg_en = 0;
+    msg[0] = (addr << 4) | 0x0; /* 0x0, TV's root address */
+    cec_polling_online_dev(msg[0], &ret);
+    amlogic_cec_log_dbg("TV %s support CEC\n", ret ? "does" : "does not");
+    cec_msg_dbg_en = 1;
+    hdmitx_device->tv_cec_support = ret;
+    return hdmitx_device->tv_cec_support;
+}
+
+int cec_node_init(struct hdmitx_dev* hdmitx_device)
+{
+    unsigned long cec_phy_addr;
+    unsigned long spin_flags;
+    struct cec_rx_list *entry;
+    amlogic_cec_log_dbg("CEC NODE INIT\n");
+
+    cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12)
+        | (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)
+        | (((hdmitx_device->hdmi_info.vsdb_phy_addr.c) & 0xf) << 4)
+        | (((hdmitx_device->hdmi_info.vsdb_phy_addr.d) & 0xf) << 0);
+
+    cec_pinmux_set();
+    ao_cec_init();
+    cec_arbit_bit_time_set(3, 0x118, 0);
+    cec_arbit_bit_time_set(5, 0x000, 0);
+    cec_arbit_bit_time_set(7, 0x2aa, 0);
+
+    // If VSDB is not valid,use last or default physical address.
+    if (hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0)
+    {
+        amlogic_cec_log_dbg("no valid cec physical address\n");
+        if (cec_phyaddr_config(0, 0))
+        {
+            amlogic_cec_log_dbg("use last physical address\n");
+        }
+        else
+        {
+            hd_write_reg(P_AO_DEBUG_REG1, (hd_read_reg(P_AO_DEBUG_REG1) & (0xf << 16)) | 0x1000);
+            amlogic_cec_log_dbg("use default physical address\n");
+        }
+    }
+    else
+    {
+        if (cec_global_info.my_node_index)
+        {
+            // prevent write operations
+            if (down_interruptible(&init_mutex))
+            {
+                printk(KERN_ERR "[amlogic] ##### cec node init interrupted! #####\n");
+                return -1;
+            }
+            hdmitx_device->cec_init_ready = 0;
+            spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+
+            amlogic_cec_log_dbg("start reset\n");
+            cec_hw_reset();
+
+            // regain rx interrupts
+            cec_enable_irq();
+            spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+
+            hdmitx_device->cec_init_ready = 1;
+
+            up(&init_mutex);
+            amlogic_cec_log_dbg("stop reset\n");
+        }
+
+        if ((hd_read_reg(P_AO_DEBUG_REG1) & 0xffff) != cec_phy_addr)
+        {
+            hd_write_reg(P_AO_DEBUG_REG1, (hd_read_reg(P_AO_DEBUG_REG1) & (0xf << 16)) | cec_phy_addr);
+            amlogic_cec_log_dbg("physical address:0x%x\n", hd_read_reg(P_AO_DEBUG_REG1) & 0xffff);
+
+            if ((hdmitx_device->cec_init_ready != 0) && (hdmitx_device->hpd_state != 0))
+            {
+                if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
+                {
+                    amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
+                }
+                else
+                {
+                    // let the libCEC ask for new physical Address
+                    entry->buffer[0] = 0xff;
+                    entry->size = 1;
+                    INIT_LIST_HEAD(&entry->list);
+
+                    spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+                    list_add_tail(&entry->list, &cec_rx_struct.list);
+                    amlogic_cec_set_rx_state(STATE_DONE);
+                    spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+
+                    amlogic_cec_log_dbg("trigger libCEC\n");
+                    wake_up_interruptible(&cec_rx_struct.waitq);
+                }
+            }
+        }
+    }
+    return 0;
+}
+
+static irqreturn_t amlogic_cec_irq_handler(int irq, void *dummy)
+{
+    unsigned long spin_flags;
+    struct cec_rx_list *entry;
+    unsigned int tx_msg_state;
+    unsigned int rx_msg_state;
+
+
+    tx_msg_state = amlogic_cec_read_reg(CEC_TX_MSG_STATUS);
+    rx_msg_state = amlogic_cec_read_reg(CEC_RX_MSG_STATUS);
+
+    amlogic_cec_log_dbg("cec msg status: rx: 0x%x; tx: 0x%x\n", rx_msg_state, tx_msg_state);
+
+    if ((tx_msg_state == TX_DONE) || (tx_msg_state == TX_ERROR))
+    {
+        amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+
+        switch (tx_msg_state) {
+            case TX_ERROR :
+                amlogic_cec_set_tx_state(STATE_ERROR);
+                break;
+            case TX_DONE :
+                amlogic_cec_set_tx_state(STATE_DONE);
+                break;
+        }
+        wake_up_interruptible(&cec_tx_struct.waitq);
+    }
+
+    if (rx_msg_state == RX_DONE)
+    {
+
+        if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
+        {
+            amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
+            return IRQ_HANDLED;
+        }
+
+        INIT_LIST_HEAD(&entry->list);
+
+        spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+
+        if ((-1) == amlogic_cec_read_hw(entry->buffer, &entry->size))
+        {
+            kfree(entry);
+            amlogic_cec_log_dbg("amlogic_cec_irq_handler: nothing to read\n");
+            spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+            return IRQ_HANDLED;
+        }
+
+        list_add_tail(&entry->list, &cec_rx_struct.list);
+        amlogic_cec_set_rx_state(STATE_DONE);
+        spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+
+        wake_up_interruptible(&cec_rx_struct.waitq);
+    }
+
+    return IRQ_HANDLED;
+}
+
+static int amlogic_cec_open(struct inode *inode, struct file *file)
+{
+    int ret = 0;
+    int irq_idx = 0;
+    unsigned int reg;
+
+    // TODO return -EOPNOTSUPP if cec is not supported by TV
+    if (!(hdmitx_device->tv_cec_support) && (!detect_tv_support_cec(0xE)))
+        return -EOPNOTSUPP;
+
+    if (atomic_read(&hdmi_on))
+    {
+        amlogic_cec_log_dbg("do not allow multiple open for tvout cec\n");
+        ret = -EBUSY;
+    }
+    else
+    {
+        atomic_inc(&hdmi_on);
+        irq_idx = hdmitx_device->irq_cec;
+
+        reg = hd_read_reg(P_AO_RTI_PIN_MUX_REG);
+        amlogic_cec_log_dbg("P_AO_RTI_PIN_MUX_REG:%d\n", reg);
+        amlogic_cec_log_dbg("Requesting irq. irq_idx: %d\n", irq_idx);
+        if (request_irq(irq_idx, &amlogic_cec_irq_handler,
+                    IRQF_SHARED, "hdmitx_cec",(void *)hdmitx_device))
+        {
+            amlogic_cec_log_dbg("Can't register IRQ %d\n", irq_idx);
+            return -EFAULT;
+        }
+
+        cec_logicaddr_set(0xf);
+
+        hdmitx_device->cec_init_ready = 1;
+    }
+    return ret;
+}
+
+static int amlogic_cec_release(struct inode *inode, struct file *file)
+{
+    int irq_idx = 0;
+    irq_idx = hdmitx_device->irq_cec;
+    free_irq(irq_idx, (void *)hdmitx_device);
+
+    cec_logicaddr_set(0xf);
+
+    atomic_dec(&hdmi_on);
+
+    return 0;
+}
+
+static ssize_t amlogic_cec_read(struct file *file, char __user *buffer,
+        size_t count, loff_t *ppos)
+{
+    ssize_t retval;
+    unsigned long spin_flags;
+    struct cec_rx_list* entry = NULL;
+
+    if (wait_event_interruptible(cec_rx_struct.waitq,
+                atomic_read(&cec_rx_struct.state) == STATE_DONE))
+    {
+        amlogic_cec_log_dbg("error during wait on state change\n");
+        return -ERESTARTSYS;
+    }
+
+    spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+
+    entry = list_first_entry_or_null(&cec_rx_struct.list, struct cec_rx_list, list);
+
+    if (entry == NULL || entry->size > count)
+    {
+        amlogic_cec_log_dbg("entry is NULL, or empty\n");
+        retval = -1;
+        goto error_exit;
+    }
+
+    if (copy_to_user(buffer, entry->buffer, entry->size))
+    {
+        printk(KERN_ERR " copy_to_user() failed!\n");
+
+        retval = -EFAULT;
+        goto error_exit;
+    }
+
+    retval = entry->size;
+
+error_exit:
+    if (entry != NULL)
+    {
+        list_del(&entry->list);
+        kfree(entry);
+    }
+
+    if (list_empty(&cec_rx_struct.list))
+     {
+         amlogic_cec_set_rx_state(STATE_RX);
+     }
+
+    spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+
+    return retval;
+}
+
+static ssize_t amlogic_cec_write(struct file *file, const char __user *buffer,
+        size_t count, loff_t *ppos)
+{
+    int retval = count;
+    char data[CEC_TX_BUFF_SIZE];
+
+    /* check data size */
+    if (count > CEC_TX_BUFF_SIZE || count == 0)
+        return -1;
+
+    if (copy_from_user(data, buffer, count))
+    {
+        printk(KERN_ERR " copy_from_user() failed!\n");
+        return -EFAULT;
+    }
+
+    amlogic_cec_set_tx_state(STATE_TX);
+
+    // don't write if cec_node_init() is in progress
+    if (down_interruptible(&init_mutex))
+    {
+        amlogic_cec_log_dbg("error during wait on state change\n");
+        printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
+        return -ERESTARTSYS;
+    }
+
+    amlogic_cec_write_hw(data, count);
+
+    if (wait_event_interruptible_timeout(cec_tx_struct.waitq,
+                atomic_read(&cec_tx_struct.state) != STATE_TX, 2 * HZ) <= 0)
+    {
+        amlogic_cec_log_dbg("error during wait on state change, resetting\n");
+        printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
+        amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_ABORT); // stop cec tx for hw retry.
+        amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+        retval = -ERESTARTSYS;
+        goto error_exit;
+    }
+
+    if (atomic_read(&cec_tx_struct.state) != STATE_DONE)
+    {
+        printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
+        retval = -1;
+    }
+
+error_exit:
+    up(&init_mutex);
+
+    return retval;
+}
+
+static long amlogic_cec_ioctl(struct file *file, unsigned int cmd,
+        unsigned long arg)
+{
+    unsigned char logical_addr;
+
+    switch(cmd) {
+        case CEC_IOC_SETLADDR:
+            if (get_user(logical_addr, (unsigned char __user *)arg))
+            {
+                amlogic_cec_log_dbg("Failed to get logical addr from user\n");
+                return -EFAULT;
+            }
+
+            cec_logicaddr_set(logical_addr);
+            cec_global_info.my_node_index = logical_addr;
+            cec_logicaddr_config(logical_addr, 1);
+
+            amlogic_cec_log_dbg("amlogic_cec_ioctl: Set logical address: %d\n", logical_addr);
+            return 0;
+
+        case CEC_IOC_GETPADDR:
+            amlogic_cec_log_dbg("amlogic_cec_ioctl: return physical address 0x%x\n", hd_read_reg(P_AO_DEBUG_REG1) & 0xffff);
+            return hd_read_reg(P_AO_DEBUG_REG1) & 0xffff;
+    }
+
+    return -EINVAL;
+}
+
+static u32 amlogic_cec_poll(struct file *file, poll_table *wait)
+{
+
+    if (atomic_read(&cec_rx_struct.state) != STATE_DONE)
+    {
+        poll_wait(file, &cec_rx_struct.waitq, wait);
+    }
+    if (atomic_read(&cec_rx_struct.state) == STATE_DONE)
+    {
+        return POLLIN | POLLRDNORM;
+    }
+    return 0;
+}
+
+static const struct file_operations cec_fops = {
+    .owner   = THIS_MODULE,
+    .open    = amlogic_cec_open,
+    .release = amlogic_cec_release,
+    .read    = amlogic_cec_read,
+    .write   = amlogic_cec_write,
+    .unlocked_ioctl = amlogic_cec_ioctl,
+    .poll    = amlogic_cec_poll,
+};
+
+static struct miscdevice cec_misc_device = {
+    .minor = CEC_MINOR,
+    .name  = "AmlogicCEC",
+    .fops  = &cec_fops,
+};
+
+static ssize_t show_amlogic_cec_debug_config(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return snprintf(buf, PAGE_SIZE, "amlogic_cec_debug:%lu\n", amlogic_cec_debug_flag);
+}
+
+static ssize_t store_amlogic_cec_debug_config(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+    return kstrtoul(buf, 16, &amlogic_cec_debug_flag) ? 0 : count;
+}
+
+static DEVICE_ATTR(amlogic_cec_debug_config, S_IWUSR | S_IRUGO | S_IWGRP, show_amlogic_cec_debug_config, store_amlogic_cec_debug_config);
+
+static int aml_cec_probe(struct platform_device *pdev)
+{
+#ifdef CONFIG_OF
+    struct device_node *node = pdev->dev.of_node;
+    int irq_idx = 0, r;
+    const char *pin_name = NULL;
+    struct pinctrl *p;
+    struct device *dev;
+
+    /* pinmux set */
+    if (of_get_property(node, "pinctrl-names", NULL)) {
+        r = of_property_read_string(node,
+                "pinctrl-names",
+                &pin_name);
+        if (!r) {
+            p = devm_pinctrl_get_select(&pdev->dev, pin_name);
+        }
+    }
+
+    irq_idx = of_irq_get(node, 0);
+    hdmitx_device->irq_cec = irq_idx;
+    amlogic_cec_log_dbg("cec platform init done. irq_idx: %d\n", irq_idx);
+    dev = dev_get_platdata(&pdev->dev);
+    if (dev) {
+        r = device_create_file(dev, &dev_attr_amlogic_cec_debug_config);
+    }
+#endif
+    return 0;
+}
+
+static int aml_cec_remove(struct platform_device *pdev)
+{
+    struct device *dev;
+
+    amlogic_cec_log_dbg("cec platform uninit!\n");
+    dev = dev_get_platdata(&pdev->dev);
+    if (dev) {
+        device_remove_file(dev, &dev_attr_amlogic_cec_debug_config);
+    }
+    return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id aml_cec_dt_match[] = {
+    {
+        .compatible = "amlogic, amlogic-cec",
+    },
+    {},
+};
+#endif
+
+static struct platform_driver aml_cec_driver = {
+    .driver = {
+        .name  = "amlogic-cec",
+        .owner = THIS_MODULE,
+#ifdef CONFIG_OF
+        .of_match_table = aml_cec_dt_match,
+#endif
+    },
+    .probe  = aml_cec_probe,
+    .remove = aml_cec_remove,
+};
+
+static int __init amlogic_cec_init(void)
+{
+    int retval = 0;
+    extern struct hdmitx_dev * get_hdmitx_device(void);
+
+    if (down_interruptible(&init_mutex))
+    {
+        return -ERESTARTSYS;
+    }
+
+    INIT_LIST_HEAD(&cec_rx_struct.list);
+    hdmitx_device = get_hdmitx_device();
+    printk("%s, Version: %s\n", banner, VERSION);
+    amlogic_cec_log_dbg("CEC init\n");
+
+    // register platform driver
+    platform_driver_register(&aml_cec_driver);
+
+    cec_logicaddr_set(0xf);
+
+
+    init_waitqueue_head(&cec_rx_struct.waitq);
+
+    spin_lock_init(&cec_rx_struct.lock);
+
+    init_waitqueue_head(&cec_tx_struct.waitq);
+
+    spin_lock_init(&cec_tx_struct.lock);
+
+    if (misc_register(&cec_misc_device))
+    {
+        printk(KERN_WARNING " Couldn't register device 10, %d.\n", CEC_MINOR);
+        retval = -EBUSY;
+    }
+
+    // release initial lock on init_mutex
+    up(&init_mutex);
+
+    amlogic_cec_log_dbg("CEC init finished: %d\n", retval);
+
+    return retval;
+}
+
+static void amlogic_cec_exit(void)
+{
+    misc_deregister(&cec_misc_device);
+}
+
+module_init(amlogic_cec_init);
+module_exit(amlogic_cec_exit);
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_cec.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_cec.c
index bce37b1..c9b182f 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_cec.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_cec.c
@@ -137,6 +137,14 @@ unsigned int menu_lang_array[] = {
 static unsigned char *osd_name = "MBox";
 static unsigned int vendor_id = 0x00;
 
+static inline void wait_for_cec_rx(void)
+{
+
+	while (cec_global_info.cec_rx_msg_buf.rx_read_pos ==
+		cec_global_info.cec_rx_msg_buf.rx_write_pos)
+		msleep(20);
+}
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
 static struct early_suspend hdmitx_cec_early_suspend_handler;
@@ -309,9 +317,9 @@ int cec_node_init(struct hdmitx_dev *hdmitx_device)
 	int i, bool = 0;
 	int phy_addr_ok = 1;
 	const enum _cec_log_dev_addr_e player_dev[3] = {
-		CEC_PLAYBACK_DEVICE_1_ADDR,
-		CEC_PLAYBACK_DEVICE_2_ADDR,
-		CEC_PLAYBACK_DEVICE_3_ADDR,
+		CEC_RECORDING_DEVICE_1_ADDR,
+		CEC_RECORDING_DEVICE_2_ADDR,
+		CEC_RECORDING_DEVICE_3_ADDR,
 	};
 
 	unsigned long cec_phy_addr;
@@ -444,6 +452,18 @@ int cec_node_init(struct hdmitx_dev *hdmitx_device)
 			}
 			cec_device_vendor_id((struct cec_rx_message_t *)0);
 
+			/* Disable switch TV on automatically */
+			if (!(hdmitx_device->cec_func_config &
+			     (1 << AUTO_POWER_ON_MASK))) {
+				cec_usrcmd_get_device_power_status(CEC_TV_ADDR);
+				msleep(200);
+				wait_for_cec_rx();
+				cec_isr_post_process();
+
+				if (cec_global_info.tv_power_status)
+					return 0;
+			}
+
 			cec_imageview_on_smp();
 
 			cec_active_source_smp();
@@ -1251,7 +1271,7 @@ void cec_give_deck_status(struct cec_rx_message_t *pcec_message)
 
 	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
 	msg[1] = CEC_OC_DECK_STATUS;
-	msg[2] = 0x1a;
+	msg[2] = 0x20;
 	cec_ll_tx(msg, 3);
 }
 
@@ -1403,6 +1423,8 @@ void cec_handle_message(struct cec_rx_message_t *pcec_message)
 		case CEC_OC_REPORT_PHYSICAL_ADDRESS:
 			break;
 		case CEC_OC_REPORT_POWER_STATUS:
+			cec_global_info.tv_power_status =
+				pcec_message->content.msg.operands[0];
 			break;
 		case CEC_OC_SET_OSD_NAME:
 			break;
@@ -1439,10 +1461,12 @@ void cec_handle_message(struct cec_rx_message_t *pcec_message)
 			if (cec_global_info.cec_node_info[cec_global_info
 			    .my_node_index].menu_status != DEVICE_MENU_ACTIVE)
 				break;
+#ifndef CONFIG_ARCH_MESON64_ODROIDC2
 			/* do not active soruce when standby */
 			if (cec_global_info.cec_node_info[cec_global_info.
 				my_node_index].power_status == POWER_STANDBY)
 				break;
+#endif
 			cec_active_source_smp();
 			break;
 		case CEC_OC_GIVE_DEVICE_POWER_STATUS:
@@ -1508,6 +1532,15 @@ void cec_handle_message(struct cec_rx_message_t *pcec_message)
 				break;
 			}
 			break;
+		case CEC_OC_VENDOR_COMMAND:
+			if (pcec_message->content.msg.operands[0] == 0x1) {
+				cec_report_power_status(pcec_message);
+				cec_send_simplink_alive(pcec_message);
+			} else if (pcec_message->content.msg.operands[0]
+					== 0x4) {
+				cec_send_simplink_ack(pcec_message);
+			}
+			break;
 		case CEC_OC_GET_MENU_LANGUAGE:
 		case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
 		case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
@@ -1527,7 +1560,6 @@ void cec_handle_message(struct cec_rx_message_t *pcec_message)
 		case CEC_OC_TUNER_DEVICE_STATUS:
 		case CEC_OC_TUNER_STEP_DECREMENT:
 		case CEC_OC_TUNER_STEP_INCREMENT:
-		case CEC_OC_VENDOR_COMMAND:
 		case CEC_OC_SELECT_ANALOGUE_SERVICE:
 		case CEC_OC_SELECT_DIGITAL_SERVICE:
 		case CEC_OC_SET_ANALOGUE_TIMER:
@@ -1840,6 +1872,33 @@ void cec_routing_information(struct cec_rx_message_t *pcec_message)
 		    .menu_status = DEVICE_MENU_INACTIVE;
 	}
 }
+
+void cec_send_simplink_alive(struct cec_rx_message_t *pcec_message)
+{
+	unsigned char index = cec_global_info.my_node_index;
+	unsigned char msg[4];
+
+	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+	msg[1] = CEC_OC_VENDOR_COMMAND;
+	msg[2] = 0x2;
+	msg[3] = 0x5;
+
+	cec_ll_tx(msg, 4);
+}
+
+void cec_send_simplink_ack(struct cec_rx_message_t *pcec_message)
+{
+	unsigned char index = cec_global_info.my_node_index;
+	unsigned char msg[4];
+
+	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+	msg[1] = CEC_OC_VENDOR_COMMAND;
+	msg[2] = 0x5;
+	msg[3] = 0x1;
+
+	cec_ll_tx(msg, 4);
+}
+
 /******************** cec middle level code end ***************************/
 
 static struct notifier_block cec_reboot_nb;
@@ -1852,6 +1911,8 @@ static int cec_reboot(struct notifier_block *nb, unsigned long state, void *cmd)
 		cec_menu_status_smp(DEVICE_MENU_INACTIVE);
 		cec_inactive_source();
 	}
+	cec_usrcmd_set_config("0", 1);
+
 	return 0;
 }
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
index 7d21afc..4787300 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_edid.c
@@ -63,7 +63,7 @@
 #define EDID_DETAILED_TIMING_DES_BLOCK2_POS 0x5A
 #define EDID_DETAILED_TIMING_DES_BLOCK3_POS 0x6C
 
-static unsigned char __nosavedata edid_checkvalue[4] = {0};
+static unsigned char edid_checkvalue[4] = {0};
 
 static void edid_save_checkvalue(unsigned char *buf, unsigned int block_cnt)
 {
@@ -318,7 +318,7 @@ void set_vsdb_phy_addr(struct vsdb_phyaddr *vsdb,
 int Edid_Parse_check_HDMI_VSDB(struct hdmitx_info *info,
 	unsigned char *buff)
 {
-	unsigned char  VSpecificBoundary, BlockAddr, len;
+	unsigned char  VSpecificBoundary, BlockAddr,  len;
 	int temp_addr = 0;
 	VSpecificBoundary = buff[2];
 
@@ -1303,7 +1303,7 @@ static int hdmitx_edid_search_IEEEOUI(char *buf)
 {
 	int i;
 
-	for (i = 0; i < 0x180; i++) {
+	for (i = 0; i < 125; i++) {
 		if ((buf[i] == 0x03) && (buf[i+1] == 0x0c) &&
 			(buf[i+2] == 0x00))
 			return 1;
@@ -1350,7 +1350,6 @@ static int edid_check_valid(unsigned char *buf)
 	return 1;
 }
 
-/* retrun 1 valid edid */
 static int check_dvi_hdmi_edid_valid(unsigned char *buf)
 {
 	unsigned int chksum = 0;
@@ -1381,22 +1380,6 @@ static int check_dvi_hdmi_edid_valid(unsigned char *buf)
 	if ((chksum & 0xff) != 0)
 		return 0;
 
-	/* check block 2 checksum */
-	if (buf[0x7e] > 1) {
-		for (chksum = 0, i = 0x100; i < 0x180; i++)
-			chksum += buf[i];
-		if ((chksum & 0xff) != 0)
-			return 0;
-	}
-
-	/* check block 3 checksum */
-	if (buf[0x7e] > 2) {
-		for (chksum = 0, i = 0x180; i < 0x200; i++)
-			chksum += buf[i];
-		if ((chksum & 0xff) != 0)
-			return 0;
-	}
-
 	return 1;
 }
 
@@ -1483,13 +1466,6 @@ int hdmitx_edid_parse(struct hdmitx_dev *hdmitx_device)
 	/* Note: some DVI monitor have more than 1 block */
 	if ((BlockCount == 1) && (EDID_buf[0x81] == 1)) {
 		hdmitx_device->RXCap.IEEEOUI = 0;
-		hdmitx_device->RXCap.VIC_count = 0x3;
-		hdmitx_device->RXCap.VIC[0] = 3;
-		hdmitx_device->RXCap.VIC[1] = 4;
-		hdmitx_device->RXCap.VIC[2] = 16;
-		hdmitx_device->RXCap.native_VIC = 2;
-		hdmitx_device->vic_count = hdmitx_device->RXCap.VIC_count;
-		hdmi_print(IMP, EDID "HDMI: set default vic\n");
 		return 0;
 	} else if (BlockCount > EDID_MAX_BLOCK) {
 		BlockCount = EDID_MAX_BLOCK;
@@ -1623,6 +1599,38 @@ static struct dispmode_vic dispmode_vic_tab[] = {
 	{"2160p50hz", HDMI_4k2k_50},
 	{"2160p60hz420", HDMI_4k2k_60_y420},
 	{"2160p50hz420", HDMI_4k2k_50_y420},
+	{"640x480p60hz", HDMIV_640x480p60hz},
+	{"800x480p60hz", HDMIV_800x480p60hz},
+	{"800x600p60hz", HDMIV_800x600p60hz},
+	{"1024x600p60hz", HDMIV_1024x600p60hz},
+	{"1024x768p60hz", HDMIV_1024x768p60hz},
+	{"1280x800p60hz", HDMIV_1280x800p60hz},
+	{"1280x1024p60hz", HDMIV_1280x1024p60hz},
+/*
+/sys/class/display # echo 1280x1024p60hz > mode
+vout_serve: vmode set to 1280x1024p60hz
+
+vout_serve: disable HDMI PHY as soon as possible
+tv_vout: tv_set_current_vmode[671]fps_target_mode=43
+tv_vout: mode is 43,sync_duration_den=1,sync_duration_num=60
+tv_vout: TV mode 1280x1024p60hz selected.
+tv_vout: new mode =1280x1024 set ok
+vout_serve: vinfo mode is: 1280x1024
+vout_serve: new mode 1280x1024p60hz
+ set ok
+hdmitx: video: get current mode: 1280x1024
+ */
+	{"1280x1024", HDMIV_1280x1024p60hz}, /* alias of "1280x1024p60hz" */
+	{"1360x768p60hz", HDMIV_1360x768p60hz},
+	{"1366x768p60hz", HDMIV_1366x768p60hz},
+	{"1440x900p60hz", HDMIV_1440x900p60hz},
+	{"1600x900p60hz", HDMIV_1600x900p60hz},
+	{"1680x1050p60hz", HDMIV_1680x1050p60hz},
+	{"1920x1200p60hz", HDMIV_1920x1200p60hz},
+	{"2560x1440p60hz", HDMIV_2560x1440p60hz},
+	{"2560x1600p60hz", HDMIV_2560x1600p60hz},
+	{"2560x1080p60hz", HDMIV_2560x1080p60hz},
+	{"3440x1440p60hz", HDMIV_3440x1440p60hz},
 };
 
 int hdmitx_edid_VIC_support(enum hdmi_vic vic)
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_hdcp.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_hdcp.c
index 417411f..4b9caab 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_hdcp.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_hdcp.c
@@ -60,7 +60,7 @@ static struct switch_dev hdcp_dev = {
  * write /sys/module/hdmitx/parameters/hdmi_output_force 0
  */
 static int hdmi_output_force = 1;
-static int hdmi_authenticated;
+static int hdmi_authenticated = -1;
 static int hdmi_hdcp_process = 1;
 
 /* Notic: the HDCP key setting has been moved to uboot
@@ -99,6 +99,8 @@ static void hdcp_monitor_func(unsigned long arg)
 
 static int hdmitx_hdcp_task(void *data)
 {
+	static int err_cnt;
+	static int time_cnt;
 	struct hdmitx_dev *hdmitx_device = (struct hdmitx_dev *)data;
 
 	init_timer(&hdcp_monitor_timer);
@@ -110,7 +112,55 @@ static int hdmitx_hdcp_task(void *data)
 	while (hdmitx_device->hpd_event != 0xff) {
 		hdmi_authenticated = hdmitx_device->HWOp.CntlDDC(
 			hdmitx_device, DDC_HDCP_GET_AUTH, 0);
-		msleep_interruptible(200);
+		if ((hdmitx_device->output_blank_flag == 1) &&
+			(hdmitx_device->hpd_state == 1) &&
+			(hdmitx_device->cur_VIC != HDMI_Unkown)) {
+			err_cnt = 0;
+		time_cnt = 1;
+		hdmitx_device->output_blank_flag = 0;
+#ifdef CONFIG_AML_HDMI_TX_HDCP
+		hdmi_print(INF, HDCP "start hdcp\n");
+		hdmitx_device->HWOp.CntlDDC(hdmitx_device, AVMUTE_OFF, 0);
+		hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_RESET_EDID, 0);
+		hdmitx_device->HWOp.CntlDDC(hdmitx_device,
+			DDC_EDID_READ_DATA, 0);
+		hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_RESET_HDCP, 0);
+		hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_HDCP_OP,
+			HDCP_ON);
+		msleep(100);
+		while ((hdmitx_device->hpd_state == 1) &&
+			(hdmitx_device->cur_VIC != HDMI_Unkown)) {
+			hdmi_authenticated = hdmitx_device->HWOp.CntlDDC(
+				hdmitx_device, DDC_HDCP_GET_AUTH, 0);
+			switch_set_state(&hdcp_dev, hdmi_authenticated);
+			hdmitx_device->HWOp.CntlConfig(hdmitx_device,
+				CONF_VIDEO_BLANK_OP,
+				hdmi_authenticated ? VIDEO_UNBLANK :
+				VIDEO_BLANK);
+			hdmitx_device->HWOp.CntlConfig(hdmitx_device,
+				CONF_AUDIO_MUTE_OP,
+				hdmi_authenticated ? AUDIO_UNMUTE : AUDIO_MUTE);
+			if (!hdmi_authenticated) {
+				err_cnt++;
+				if (err_cnt & (3 << time_cnt)) {
+					time_cnt++;
+					hdmi_print(ERR, HDCP
+						"authenticated failed\n");
+				}
+			}
+			msleep(20);
+			if (hdmitx_device->output_blank_flag == 1)
+				break;
+		}
+#else
+		hdmitx_device->HWOp.CntlConfig(hdmitx_device,
+			CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+		/* hdmitx_device->HWOp.CntlConfig(hdmitx_device,
+			CONF_AUDIO_MUTE_OP, AUDIO_UNMUTE); */
+		hdmitx_device->audio_step = 1;
+#endif
+	 }
+	 msleep_interruptible(100);
 	}
 
 	return 0;
@@ -120,14 +170,11 @@ static int __init hdmitx_hdcp_init(void)
 {
 	struct hdmitx_dev *hdmitx_device = get_hdmitx_device();
 
-	hdmi_print(IMP, SYS "hdmitx_hdcp_init\n");
-	if (hdmitx_device->hdtx_dev == NULL) {
-		hdmi_print(IMP, SYS "exit for null device of hdmitx!\n");
-		return -ENODEV;
-	}
-
 	switch_dev_register(&hdcp_dev);
 
+	if(hdmitx_device->HWOp.CntlDDC == NULL)
+		return 0;
+
 	hdmitx_device->task_hdcp = kthread_run(hdmitx_hdcp_task,
 		(void *)hdmitx_device, "kthread_hdcp");
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
index 8cf3178..07b1db3 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_main.c
@@ -73,8 +73,6 @@ static int set_disp_mode_auto(void);
 const struct vinfo_s *hdmi_get_current_vinfo(void);
 static int edid_rx_data(unsigned char regaddr, unsigned char *rx_data,
 	int length);
-static int edid_rx_ext_data(unsigned char *ext, unsigned char regaddr,
-	unsigned char *rx_data,	int length);
 static void gpio_read_edid(unsigned char *rx_edid);
 
 #ifndef CONFIG_AM_TV_OUTPUT
@@ -106,9 +104,6 @@ static struct hdmitx_dev hdmitx_device;
 static struct switch_dev sdev = { /* android ics switch device */
 	.name = "hdmi",
 };
-static struct switch_dev hdmi_power = { /* android ics switch device */
-	.name = "hdmi_power",
-};
 #ifdef CONFIG_HAS_EARLYSUSPEND
 #include <linux/earlysuspend.h>
 static void hdmitx_early_suspend(struct early_suspend *h)
@@ -126,27 +121,18 @@ static void hdmitx_early_suspend(struct early_suspend *h)
 		HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_EARLY_SUSPEND);
 	phdmi->cur_VIC = HDMI_Unkown;
 	phdmi->output_blank_flag = 0;
-	phdmi->HWOp.CntlDDC(phdmi, DDC_HDCP_MUX_INIT, 1);
-	phdmi->HWOp.CntlDDC(phdmi, DDC_HDCP_OP, HDCP14_OFF);
+	phdmi->HWOp.CntlDDC(phdmi, DDC_HDCP_OP, HDCP_OFF);
 	phdmi->HWOp.CntlDDC(phdmi, DDC_HDCP_OP, DDC_RESET_HDCP);
 	if (phdmi->gpio_i2c_enable) {
-		hdmi_print(INF, SYS "unmux DDC for gpio read edid\n");
-		phdmi->HWOp.CntlDDC(phdmi, DDC_PIN_MUX_OP, PIN_UNMUX);
+		if (phdmi->hdcpop.hdcp14_en) {
+			hdmi_print(INF, SYS "unmux DDC for gpio read edid\n");
+			phdmi->HWOp.CntlDDC(phdmi, DDC_PIN_MUX_OP, PIN_UNMUX);
+		}
 	}
-	switch_set_state(&hdmi_power, 0);
 	phdmi->HWOp.CntlConfig(&hdmitx_device, CONF_CLR_AVI_PACKET, 0);
 	phdmi->HWOp.CntlConfig(&hdmitx_device, CONF_CLR_VSDB_PACKET, 0);
 	hdmi_print(IMP, SYS "HDMITX: early suspend\n");
-}
-
-static int hdmitx_is_hdmi_vmode(char *mode_name)
-{
-	enum hdmi_vic vic = hdmitx_edid_vic_tab_map_vic(mode_name);
-
-	if (vic == HDMI_Unkown)
-		return 0;
-
-	return 1;
+	phdmi->HWOp.CntlMisc(&hdmitx_device, MISC_HPLL_FAKE, 0);
 }
 
 static void hdmitx_late_resume(struct early_suspend *h)
@@ -162,20 +148,17 @@ static void hdmitx_late_resume(struct early_suspend *h)
 		hdmitx_device.HWOp.CntlConfig(&hdmitx_device,
 			CONF_VIDEO_BLANK_OP, VIDEO_BLANK);
 	}
-
-	if (1 == hdmitx_is_hdmi_vmode(info->name))
-		phdmi->HWOp.CntlMisc(&hdmitx_device, MISC_HPLL_FAKE, 0);
-
 	phdmi->hpd_lock = 0;
 
 	/* update status for hpd and switch/state */
 	hdmitx_device.hpd_state = !!(hdmitx_device.HWOp.CntlMisc(&hdmitx_device,
 		MISC_HPD_GPI_ST, 0));
 	switch_set_state(&sdev, hdmitx_device.hpd_state);
-	switch_set_state(&hdmi_power, hdmitx_device.hpd_state);
 
 	hdmitx_device.HWOp.CntlConfig(&hdmitx_device,
 		CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+	hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP,
+		HDCP_OFF);
 	hdmitx_device.internal_mode_change = 0;
 	set_disp_mode_auto();
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
@@ -236,7 +219,7 @@ static int hdmi_prbs_mode = 0xffff;
 static int hdmi_480p_force_clk; /* 200, 225, 250, 270 */
 static int hdmi_detect_when_booting = 1;
 /* 1: error  2: important  3: normal  4: detailed */
-static int debug_level = INF;
+static int debug_level = IMP;
 
 /*****************************
 *	hdmitx attr management :
@@ -396,8 +379,8 @@ static void hdmitx_pre_display_init(void)
 		CONF_VIDEO_BLANK_OP, VIDEO_BLANK);
 	hdmitx_device.HWOp.CntlConfig(&hdmitx_device,
 		CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
-	hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_MUX_INIT, 1);
-	hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP14_OFF);
+	hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP,
+		HDCP_OFF);
 	/* msleep(10); */
 	hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP,
 		TMDS_PHY_DISABLE);
@@ -470,6 +453,9 @@ static int set_disp_mode_auto(void)
 		(strncmp(info->name, "panel", 5) == 0) ||
 		(strncmp(info->name, "null", 4) == 0)) {
 		hdmi_print(ERR, VID "%s not valid hdmi mode\n", info->name);
+		/*if (hdmitx_device.hdcpop.hdcp14_en)
+			hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
+				DDC_HDCP_OP, HDCP_ON);*/
 	hdmitx_device.HWOp.CntlConfig(&hdmitx_device,
 		CONF_CLR_AVI_PACKET, 0);
 	hdmitx_device.HWOp.CntlConfig(&hdmitx_device,
@@ -519,7 +505,9 @@ static int set_disp_mode_auto(void)
 		}
 		hdmitx_device.cur_VIC = vic;
 		hdmitx_device.output_blank_flag = 1;
-		hdmitx_device.ready = 1;
+		if (hdmitx_device.hdcpop.hdcp14_en)
+			hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
+				DDC_HDCP_OP, HDCP_ON);
 		return 1;
 	} else
 		hdmitx_pre_display_init();
@@ -574,19 +562,9 @@ static int set_disp_mode_auto(void)
 	hdmitx_set_audio(&hdmitx_device,
 		&(hdmitx_device.cur_audio_param), hdmi_ch);
 	hdmitx_device.output_blank_flag = 1;
-	if (hdmitx_device.hdcp_mode == 1) {
+	if (hdmitx_device.hdcpop.hdcp14_en)
 		hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
-			DDC_HDCP_MUX_INIT, 1);
-		hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
-			DDC_HDCP_OP, HDCP14_ON);
-	}
-	if (hdmitx_device.hdcp_mode == 2) {
-		hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
-			DDC_HDCP_MUX_INIT, 2);
-		hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
-			DDC_HDCP_OP, HDCP22_ON);
-	}
-	hdmitx_device.ready = 1;
+			DDC_HDCP_OP, HDCP_ON);
 	return ret;
 }
 static unsigned char is_dispmode_valid_for_hdmi(void)
@@ -911,7 +889,10 @@ static ssize_t store_config(struct device *dev,
 		/* First, disable HDMI TMDS */
 		hdmitx_device.HWOp.CntlMisc(&hdmitx_device,
 			MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
-		/* Second, set 3D parameters */
+		if (hdmitx_device.hdcpop.hdcp14_en)
+			hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
+				DDC_HDCP_OP, HDCP_OFF);
+			/* Second, set 3D parameters */
 		if (strncmp(buf+2, "tb", 2) == 0)
 			hdmi_set_3d(&hdmitx_device, 6, 0);
 		else if (strncmp(buf+2, "lr", 2) == 0) {
@@ -927,6 +908,9 @@ static ssize_t store_config(struct device *dev,
 		msleep(20);
 		hdmitx_device.HWOp.CntlMisc(&hdmitx_device,
 			MISC_TMDS_PHY_OP, TMDS_PHY_ENABLE);
+		if (hdmitx_device.hdcpop.hdcp14_en)
+			hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
+				DDC_HDCP_OP, HDCP_ON);
 	} else if (strncmp(buf, "audio_", 6) == 0) {
 		if (strncmp(buf+6, "off", 3) == 0) {
 			hdmitx_audio_mute_op(0);
@@ -979,6 +963,24 @@ const char *disp_mode_t[] = {
 	"2160p60hz",
 	"2160p50hz420",
 	"2160p60hz420",
+	/* VESA modes */
+	"640x480p60hz",
+	"800x480p60hz",
+	"800x600p60hz",
+	"1024x600p60hz",
+	"1024x768p60hz",
+	"1280x800p60hz",
+	"1280x1024p60hz",
+	"1360x768p60hz",
+	"1366x768p60hz",
+	"1440x900p60hz",
+	"1600x900p60hz",
+	"1680x1050p60hz",
+	"1920x1200p60hz",
+	"2560x1440p60hz",
+	"2560x1600p60hz",
+	"2560x1080p60hz",
+	"3440x1440p60hz",
 	NULL
 };
 
@@ -1144,12 +1146,6 @@ static ssize_t store_avmute(struct device *dev,
 	return count;
 }
 
-static ssize_t show_avmute(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	return 0;
-}
-
 /*
  *  1: enable hdmitx phy
  *  0: disable hdmitx phy
@@ -1163,150 +1159,20 @@ static ssize_t store_phy(struct device *dev,
 	else if (strncmp(buf, "1", 1) == 0)
 		cmd = TMDS_PHY_ENABLE;
 	else
-		pr_info("hdmitx: set phy wrong: %s\n", buf);
+		pr_info("set avmute wrong: %s\n", buf);
 
 	hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, cmd);
 	return count;
 }
 
-static ssize_t show_phy(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	return 0;
-}
-
-static ssize_t store_hdcp_clkdis(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	pr_info("set hdcp clkdis: %s\n", buf);
-
-	hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_HDCP_CLKDIS,
-		(buf[0] == '1') ? 1 : 0);
-	return count;
-}
-
-static ssize_t show_hdcp_clkdis(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	return 0;
-}
-
 static ssize_t store_hdcp_byp(struct device *dev,
 	struct device_attribute *attr, const char *buf, size_t count)
 {
-	hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_BYP, 0);
+	hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
 
 	return count;
 }
 
-static int lstore;
-static ssize_t show_hdcp_lstore(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	int pos = 0;
-	if (lstore < 0x10) {
-		lstore = 0;
-		if (hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
-			DDC_HDCP_14_LSTORE, 0))
-			lstore += 1;
-		if (hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
-			DDC_HDCP_22_LSTORE, 0))
-			lstore += 2;
-	}
-	if (lstore & 0x1)
-		pos += snprintf(buf + pos, PAGE_SIZE, "14\n");
-	if (lstore & 0x2)
-		pos += snprintf(buf + pos, PAGE_SIZE, "22\n");
-	if ((lstore & 0xf) == 0)
-		pos += snprintf(buf + pos, PAGE_SIZE, "00\n");
-	return pos;
-}
-
-static ssize_t store_hdcp_lstore(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	pr_info("hdcp: set lstore as %s\n", buf);
-	if (strncmp(buf, "0", 1) == 0)
-		lstore = 0x10;
-	if (strncmp(buf, "11", 2) == 0)
-		lstore = 0x11;
-	if (strncmp(buf, "12", 2) == 0)
-		lstore = 0x12;
-	if (strncmp(buf, "13", 2) == 0)
-		lstore = 0x13;
-
-	return count;
-}
-
-
-static ssize_t show_hdcp_mode(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	int pos = 0;
-
-	switch (hdmitx_device.hdcp_mode) {
-	case 1:
-		pos += snprintf(buf + pos, PAGE_SIZE, "14");
-		break;
-	case 2:
-		pos += snprintf(buf + pos, PAGE_SIZE, "22");
-		break;
-	default:
-		pos += snprintf(buf + pos, PAGE_SIZE, "off");
-		break;
-	}
-
-	return pos;
-}
-
-static ssize_t store_hdcp_mode(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	pr_info("hdcp: set mode as %s\n", buf);
-	hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_MUX_INIT, 1);
-	if (strncmp(buf, "-1", 2) == 0) {
-		hdmitx_device.hdcp_mode = -1;
-		hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
-			DDC_HDCP_OP, HDCP14_OFF);
-	}
-	if (strncmp(buf, "0", 1) == 0)
-		hdmitx_device.hdcp_mode = 0;
-	if (strncmp(buf, "1", 1) == 0) {
-		hdmitx_device.hdcp_mode = 1;
-		hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
-			DDC_HDCP_OP, HDCP14_ON);
-	}
-	if (strncmp(buf, "2", 1) == 0) {
-		hdmitx_device.hdcp_mode = 2;
-		hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
-			DDC_HDCP_MUX_INIT, 2);
-	}
-
-	return count;
-}
-
-static ssize_t store_hdcp_ctrl(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	dev_warn(dev, "hdmitx20: %s\n", buf);
-	if (strncmp(buf, "stop", 4) == 0) {
-		if (strncmp(buf+4, "14", 2) == 0)
-			hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
-				DDC_HDCP_OP, HDCP14_OFF);
-		if (strncmp(buf+4, "22", 2) == 0)
-			hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
-				DDC_HDCP_OP, HDCP22_OFF);
-	}
-
-	return count;
-}
-
-static ssize_t show_hdcp_ctrl(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	return 0;
-}
-
 static ssize_t show_hdcp_ksv_info(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
@@ -1316,7 +1182,7 @@ static ssize_t show_hdcp_ksv_info(struct device *dev,
 	hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_GET_BKSV,
 		(unsigned long int)bksv_buf);
 
-	pos += snprintf(buf+pos, PAGE_SIZE, "HDCP14 BKSV: ");
+	pos += snprintf(buf+pos, PAGE_SIZE, "BKSV: ");
 	for (i = 0; i < 5; i++) {
 		pos += snprintf(buf+pos, PAGE_SIZE, "%02x",
 			bksv_buf[i]);
@@ -1327,32 +1193,6 @@ static ssize_t show_hdcp_ksv_info(struct device *dev,
 	return pos;
 }
 
-static ssize_t show_hdcp_ver(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	int pos = 0;
-	uint32_t ver;
-
-	/* Detect RX support HDCP22 */
-	ver = hdcp_rd_hdcp22_ver();
-	if (ver) {
-		pos += snprintf(buf+pos, PAGE_SIZE, "22\n\r");
-		pos += snprintf(buf+pos, PAGE_SIZE, "14\n\r");
-		return pos;
-	}
-	/* Detect RX support HDCP14 */
-	ver = hdcp_rd_hdcp14_ver();
-	/* Here, must assume RX support HDCP14, otherwise affect 1A-03 */
-	if (1) {
-		pos += snprintf(buf+pos, PAGE_SIZE, "14\n\r");
-		return pos;
-	}
-
-	/* RX NOT support HDCP */
-	pos += snprintf(buf+pos, PAGE_SIZE, "00\n\r");
-	return pos;
-}
-
 static ssize_t show_hpd_state(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
@@ -1363,26 +1203,6 @@ static ssize_t show_hpd_state(struct device *dev,
 	return pos;
 }
 
-static ssize_t show_ready(struct device *dev,
-	struct device_attribute *attr, char *buf)
-{
-	int pos = 0;
-
-	pos += snprintf(buf+pos, PAGE_SIZE, "%d\r\n",
-		hdmitx_device.ready);
-	return pos;
-}
-
-static ssize_t store_ready(struct device *dev,
-	struct device_attribute *attr, const char *buf, size_t count)
-{
-	if (strncmp(buf, "0", 1) == 0)
-		hdmitx_device.ready = 0;
-	if (strncmp(buf, "1", 1) == 1)
-		hdmitx_device.ready = 1;
-	return count;
-}
-
 static ssize_t show_support_3d(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
@@ -1419,24 +1239,16 @@ static DEVICE_ATTR(disp_cap, S_IRUGO, show_disp_cap, NULL);
 static DEVICE_ATTR(aud_cap, S_IRUGO, show_aud_cap, NULL);
 static DEVICE_ATTR(aud_ch, S_IWUSR | S_IRUGO | S_IWGRP, show_aud_ch,
 	store_aud_ch);
-static DEVICE_ATTR(avmute, S_IWUSR | S_IRUGO | S_IWGRP, show_avmute,
-	store_avmute);
-static DEVICE_ATTR(phy, S_IWUSR | S_IRUGO | S_IWGRP, show_phy, store_phy);
-static DEVICE_ATTR(hdcp_clkdis, S_IWUSR | S_IRUGO | S_IWGRP, show_hdcp_clkdis,
-	store_hdcp_clkdis);
+static DEVICE_ATTR(avmute, S_IWUSR, NULL, store_avmute);
+static DEVICE_ATTR(phy, S_IWUSR, NULL, store_phy);
 static DEVICE_ATTR(hdcp_byp, S_IWUSR, NULL, store_hdcp_byp);
-static DEVICE_ATTR(hdcp_mode, S_IWUSR | S_IRUGO | S_IWGRP, show_hdcp_mode,
-	store_hdcp_mode);
-static DEVICE_ATTR(hdcp_lstore, S_IWUSR | S_IRUGO | S_IWGRP, show_hdcp_lstore,
-	store_hdcp_lstore);
-static DEVICE_ATTR(hdcp_ctrl, S_IWUSR | S_IRUGO | S_IWGRP, show_hdcp_ctrl,
-	store_hdcp_ctrl);
-static DEVICE_ATTR(disp_cap_3d, S_IRUGO, show_disp_cap_3d, NULL);
-static DEVICE_ATTR(hdcp_ksv_info, S_IRUGO, show_hdcp_ksv_info, NULL);
-static DEVICE_ATTR(hdcp_ver, S_IRUGO, show_hdcp_ver, NULL);
+static DEVICE_ATTR(disp_cap_3d, S_IRUGO, show_disp_cap_3d,
+	NULL);
+static DEVICE_ATTR(hdcp_ksv_info, S_IRUGO, show_hdcp_ksv_info,
+	NULL);
 static DEVICE_ATTR(hpd_state, S_IRUGO, show_hpd_state, NULL);
-static DEVICE_ATTR(ready, S_IWUSR | S_IRUGO | S_IWGRP, show_ready, store_ready);
-static DEVICE_ATTR(support_3d, S_IRUGO, show_support_3d, NULL);
+static DEVICE_ATTR(support_3d, S_IRUGO, show_support_3d,
+	NULL);
 
 /*****************************
 *	hdmitx display client interface
@@ -1630,7 +1442,7 @@ static int hdmitx_notify_callback_a(struct notifier_block *block,
 	if (audio_param->type != cmd) {
 		audio_param->type = cmd;
 	hdmi_print(INF, AUD "aout notify format %s\n",
-		aud_type_string[audio_param->type & 0xff]);
+		aud_type_string[audio_param->type]);
 	hdmitx_device.audio_param_update_flag = 1;
 	}
 
@@ -1688,7 +1500,7 @@ static int hdmitx_notify_callback_a(struct notifier_block *block,
 }
 
 struct i2c_client *i2c_edid_client;
-static int edid_read_flag __nosavedata;
+static int edid_read_flag;
 static DEFINE_MUTEX(getedid_mutex);
 static void hdmitx_get_edid(struct hdmitx_dev *hdev)
 {
@@ -1744,7 +1556,6 @@ void hdmitx_hpd_plugin_handler(struct work_struct *work)
 	hdmitx_set_audio(hdev, &(hdev->cur_audio_param), hdmi_ch);
 	switch_set_state(&sdev, 1);
 	cec_node_init(hdev);
-
 	hdev->hdmitx_event &= ~HDMI_TX_HPD_PLUGIN;
 	mutex_unlock(&setclk_mutex);
 }
@@ -1756,23 +1567,19 @@ void hdmitx_hpd_plugout_handler(struct work_struct *work)
 
 	if (!(hdev->hdmitx_event & (HDMI_TX_HPD_PLUGOUT)))
 		return;
-	hdev->hdcp_mode = 0;
-	hdev->HWOp.CntlDDC(hdev, DDC_HDCP_MUX_INIT, 1);
-	hdev->HWOp.CntlDDC(hdev, DDC_HDCP_OP, HDCP14_OFF);
 	mutex_lock(&setclk_mutex);
-	hdev->ready = 0;
 	hdev->hpd_state = 0;
 	hdev->tv_cec_support = 0;
 	hdev->HWOp.CntlConfig(hdev, CONF_CLR_AVI_PACKET, 0);
-	hdev->HWOp.CntlDDC(hdev, DDC_HDCP_MUX_INIT, 1);
-	hdev->HWOp.CntlDDC(hdev, DDC_HDCP_OP, HDCP14_OFF);
+	hdev->HWOp.CntlDDC(hdev, DDC_HDCP_OP, HDCP_OFF);
 	hdev->HWOp.CntlMisc(hdev, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
 	pr_info("hdmitx: plugout\n");
-	hdev->HWOp.CntlMisc(hdev, MISC_ESM_RESET, 0);
 	if (hdev->gpio_i2c_enable) {
 		edid_read_flag = 0;
-		hdmi_print(INF, SYS "unmux DDC for gpio read edid\n");
-		hdev->HWOp.CntlDDC(hdev, DDC_PIN_MUX_OP, PIN_UNMUX);
+		if (hdev->hdcpop.hdcp14_en) {
+			hdmi_print(INF, SYS "unmux DDC for gpio read edid\n");
+			hdev->HWOp.CntlDDC(hdev, DDC_PIN_MUX_OP, PIN_UNMUX);
+		}
 	}
 	hdmitx_edid_clear(hdev);
 	hdmitx_edid_ram_buffer_clear(hdev);
@@ -1833,7 +1640,7 @@ static int hdmi_task_handle(void *data)
 	INIT_WORK(&hdmitx_device->work_internal_intr,
 		hdmitx_internal_intr_handler);
 
-	hdmitx_device->tx_aud_cfg = 1; /* default audio configure is on */
+	/*hdmitx_device->tx_aud_cfg = 1;*/ /* default audio configure is on */
 	if (init_flag & INIT_FLAG_POWERDOWN) {
 		/* power down */
 		hdmitx_device->HWOp.SetDispMode(hdmitx_device, NULL);
@@ -2010,13 +1817,13 @@ static int get_dt_pwr_init_data(struct device_node *np,
 
 #endif
 
-#if 0
-static int edid_tx_data(unsigned char *tx_data, int length)
+static int edid_tx_segaddr(unsigned char segaddr, unsigned char *tx_data,
+	int length)
 {
 	int err;
 	struct i2c_msg msg[] = {
 		{
-			.addr = i2c_edid_client->addr,
+			.addr = segaddr,
 			.flags = 0,
 			.len = length,
 			.buf = tx_data,
@@ -2031,14 +1838,14 @@ static int edid_tx_data(unsigned char *tx_data, int length)
 		return 0;
 }
 
-static int edid_tx_segaddr(unsigned char segaddr, unsigned char *tx_data,
-	int length)
+#if 0
+static int edid_tx_data(unsigned char *tx_data, int length)
 {
 	int err;
 	struct i2c_msg msg[] = {
 		{
-			.addr = segaddr,
-			.flags = I2C_M_IGNORE_NAK | I2C_M_STOP,
+			.addr = i2c_edid_client->addr,
+			.flags = 0,
 			.len = length,
 			.buf = tx_data,
 		},
@@ -2080,68 +1887,33 @@ static int edid_rx_data(unsigned char regaddr, unsigned char *rx_data,
 		return 0;
 }
 
-static int edid_rx_ext_data(unsigned char *ext, unsigned char regaddr,
-	unsigned char *rx_data, int length)
-{
-	int err;
-	struct i2c_msg msgs[] = {
-		{ /* Wr SegAddr & SegPtr */
-			.addr = 0x30,
-			.flags = 0,
-			.len = 1,
-			.buf = ext,
-		},
-		{
-			.addr = i2c_edid_client->addr,
-			.flags = 0,
-			.len = 1,
-			.buf = &regaddr,
-		},
-		{
-			.addr = i2c_edid_client->addr,
-			.flags = I2C_M_RD,
-			.len = length,
-			.buf = rx_data,
-		},
-	};
-	err = i2c_transfer(i2c_edid_client->adapter, msgs,
-		ARRAY_SIZE(msgs));
-	if (err < 0) {
-		hdmi_print(ERR, SYS "[%s] err = %d\n", __func__, err);
-		return -EIO;
-	} else
-		return 0;
-}
-
 static void gpio_read_edid(unsigned char *rx_edid)
 {
 	int i = 0;
 	int byte_num = 0;
 	unsigned char blk_no = 1;
-	unsigned char rx_data[128];
+	unsigned char rx_data[8];
 	unsigned char segptr = 0x0;
 	unsigned char regaddr = 0x0;
-
+	edid_tx_segaddr(0x30, &segptr, 1);
 	while (byte_num < 128 * blk_no) {
-		if ((byte_num == 0) || (byte_num == 128)) {
-			segptr = 0x0;
-			edid_rx_data(regaddr & 0xff, rx_data, 128);
-		}
-		if (((byte_num == 256) || (byte_num == 384)) && (blk_no > 2)) {
-			segptr = 0x1;
-			edid_rx_ext_data(&segptr, regaddr & 0xff, rx_data, 128);
+		if ((byte_num % 256) == 0) {
+			segptr = byte_num >> 8;
+			hdmi_print(IMP, SYS "[%s] setptr = %d\n",
+				__func__, segptr);
 		}
-		regaddr = regaddr + 0x80;
-		for (i = 0; i < 128; i++) {
+		edid_rx_data(regaddr, rx_data, 8);
+		regaddr = regaddr + 8;
+		for (i = 0; i < 8; i++) {
 			rx_edid[byte_num] = rx_data[i];
-			if (byte_num == 0x7e) {
-				blk_no = rx_edid[0x7e] + 1;
-				/*read two or more blocks */
-				if (blk_no > 4) {
+			if (byte_num == 126) {
+				blk_no = rx_edid[byte_num] + 1;
+				/*only read two blocks because of segptr*/
+				if (blk_no > 2) {
 					pr_info("edid extension block number:");
 					pr_info(" %d, reset to MAX 1\n",
 						blk_no - 1);
-					blk_no = 4; /*Max extended block*/
+					blk_no = 2; /*Max extended block*/
 				}
 			}
 			byte_num++;
@@ -2153,6 +1925,13 @@ static int i2c_gpio_edid_probe(struct i2c_client *client,
 	const struct i2c_device_id *device_id)
 {
 	i2c_edid_client = client;
+	if (hdmitx_device.HWOp.CntlMisc(&hdmitx_device,
+		MISC_HPD_GPI_ST, 0)) {
+		hdmitx_get_edid(&hdmitx_device);
+		if (hdmitx_device.hdcpop.hdcp14_en)
+			hdmitx_device.HWOp.CntlDDC(&hdmitx_device,
+				DDC_HDCP_OP, HDCP_ON);
+	}
 	return 0;
 }
 
@@ -2210,8 +1989,6 @@ static int amhdmitx_probe(struct platform_device *pdev)
 	hdmitx_device.auth_process_timer = 0;
 	hdmitx_device.force_audio_flag = 0;
 	hdmitx_device.tv_cec_support = 0;
-	hdmitx_device.hdcp_mode = -1; /* no hdcp by default */
-	hdmitx_device.ready = 0;
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
 	register_early_suspend(&hdmitx_early_suspend_handler);
@@ -2248,15 +2025,9 @@ static int amhdmitx_probe(struct platform_device *pdev)
 	ret = device_create_file(dev, &dev_attr_aud_ch);
 	ret = device_create_file(dev, &dev_attr_avmute);
 	ret = device_create_file(dev, &dev_attr_phy);
-	ret = device_create_file(dev, &dev_attr_hdcp_clkdis);
 	ret = device_create_file(dev, &dev_attr_hdcp_ksv_info);
-	ret = device_create_file(dev, &dev_attr_hdcp_ver);
 	ret = device_create_file(dev, &dev_attr_hdcp_byp);
-	ret = device_create_file(dev, &dev_attr_hdcp_mode);
-	ret = device_create_file(dev, &dev_attr_hdcp_lstore);
-	ret = device_create_file(dev, &dev_attr_hdcp_ctrl);
 	ret = device_create_file(dev, &dev_attr_hpd_state);
-	ret = device_create_file(dev, &dev_attr_ready);
 	ret = device_create_file(dev, &dev_attr_support_3d);
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 	register_hdmi_edid_supported_func(hdmitx_is_vmode_supported);
@@ -2282,6 +2053,20 @@ static int amhdmitx_probe(struct platform_device *pdev)
 	if (pdev->dev.of_node) {
 		memset(&hdmitx_device.config_data, 0,
 			sizeof(struct hdmi_config_platform_data));
+/* Get HDCP cmd */
+	hdmitx_device.hdcpop.hdcp14_en = 0;
+	hdmitx_device.hdcpop.hdcp14_rslt = 0;
+	ret = of_property_read_u32(pdev->dev.of_node, "hdcp14_en", &val);
+	if (!ret)
+		hdmitx_device.hdcpop.hdcp14_en = val;
+	ret = of_property_read_u32(pdev->dev.of_node, "hdcp14_rslt", &val);
+	if (!ret)
+		hdmitx_device.hdcpop.hdcp14_rslt = val;
+	if ((hdmitx_device.hdcpop.hdcp14_en)
+		& (hdmitx_device.hdcpop.hdcp14_rslt))
+		pr_info("hdmitx hdcp14 %x %x",
+			hdmitx_device.hdcpop.hdcp14_en & 0xff,
+			hdmitx_device.hdcpop.hdcp14_rslt & 0xff);
 /*Get HDMI gpio i2c cmd*/
 	ret = of_property_read_u32(pdev->dev.of_node, "gpio_i2c_en", &val);
 	if (!ret)
@@ -2394,7 +2179,6 @@ static int amhdmitx_probe(struct platform_device *pdev)
 		clk_prepare_enable(hdmitx_device.clk_pixel);
 
 	switch_dev_register(&sdev);
-	switch_dev_register(&hdmi_power);
 
 	hdmitx_init_parameters(&hdmitx_device.hdmi_info);
 	HDMITX_Meson_Init(&hdmitx_device);
@@ -2416,7 +2200,6 @@ static int amhdmitx_remove(struct platform_device *pdev)
 {
 	struct device *dev = hdmitx_device.hdtx_dev;
 	switch_dev_unregister(&sdev);
-	switch_dev_unregister(&hdmi_power);
 
 	if (hdmitx_device.HWOp.UnInit)
 		hdmitx_device.HWOp.UnInit(&hdmitx_device);
@@ -2441,7 +2224,6 @@ static int amhdmitx_remove(struct platform_device *pdev)
 	device_remove_file(dev, &dev_attr_disp_cap);
 	device_remove_file(dev, &dev_attr_disp_cap_3d);
 	device_remove_file(dev, &dev_attr_hpd_state);
-	device_remove_file(dev, &dev_attr_ready);
 	device_remove_file(dev, &dev_attr_support_3d);
 
 	cdev_del(&hdmitx_device.cdev);
@@ -2503,36 +2285,11 @@ static int amhdmitx_resume(struct platform_device *pdev)
 }
 #endif
 
-#ifdef CONFIG_INSTABOOT
-static unsigned char __nosavedata EDID_buf_save[EDID_MAX_BLOCK * 128];
-static unsigned char __nosavedata EDID_buf1_save[EDID_MAX_BLOCK * 128];
-static unsigned char __nosavedata EDID_hash_save[20];
-static struct rx_cap __nosavedata RXCap_save;
-static struct hdmitx_info __nosavedata hdmi_info_save;
-
-static void save_device_param(void)
-{
-	memcpy(EDID_buf_save, hdmitx_device.EDID_buf, EDID_MAX_BLOCK * 128);
-	memcpy(EDID_buf1_save, hdmitx_device.EDID_buf1, EDID_MAX_BLOCK * 128);
-	memcpy(EDID_hash_save, hdmitx_device.EDID_hash, 20);
-	memcpy(&RXCap_save, &hdmitx_device.RXCap, sizeof(struct rx_cap));
-	memcpy(&hdmi_info_save, &hdmitx_device.hdmi_info,
-		sizeof(struct hdmitx_info));
-}
-
-static void restore_device_param(void)
-{
-	memcpy(hdmitx_device.EDID_buf, EDID_buf_save, EDID_MAX_BLOCK * 128);
-	memcpy(hdmitx_device.EDID_buf1, EDID_buf1_save, EDID_MAX_BLOCK * 128);
-	memcpy(hdmitx_device.EDID_hash, EDID_hash_save, 20);
-	memcpy(&hdmitx_device.RXCap, &RXCap_save, sizeof(struct rx_cap));
-	memcpy(&hdmitx_device.hdmi_info, &hdmi_info_save,
-		sizeof(struct hdmitx_info));
-}
-
+#ifdef CONFIG_HIBERNATION
+static int is_support_3d __nosavedata;
 static int amhdmitx_freeze(struct device *dev)
 {
-	save_device_param();
+	is_support_3d = hdmitx_device.RXCap.threeD_present;
 	return 0;
 }
 
@@ -2541,7 +2298,7 @@ static int amhdmitx_restore(struct device *dev)
 	int current_hdmi_state = !!(hdmitx_device.HWOp.CntlMisc(&hdmitx_device,
 			MISC_HPD_GPI_ST, 0));
 	char *vout_mode = get_vout_mode_internal();
-	restore_device_param();
+	hdmitx_device.RXCap.threeD_present = is_support_3d;
 	if (strstr(vout_mode, "cvbs") && current_hdmi_state == 1) {
 		mutex_lock(&setclk_mutex);
 		sdev.state = 0;
@@ -2596,15 +2353,7 @@ static struct platform_driver amhdmitx_driver = {
 	}
 };
 
-static int amhdmitx_device_init(struct hdmitx_dev *hdmi_dev)
-{
-	if (hdmi_dev == NULL)
-		return 1;
 
-	hdmi_dev->hdtx_dev = NULL;
-
-	return 0;
-}
 
 static int  __init amhdmitx_init(void)
 {
@@ -2614,8 +2363,6 @@ static int  __init amhdmitx_init(void)
 	hdmi_print(IMP, SYS "amhdmitx_init\n");
 	hdmi_print(IMP, SYS "Ver: %s\n", HDMITX_VER);
 
-	amhdmitx_device_init(&hdmitx_device);
-
 	if (platform_driver_register(&amhdmitx_driver)) {
 		hdmi_print(ERR, SYS
 			"failed to register amhdmitx module\n");
@@ -2720,6 +2467,9 @@ static  int __init hdmitx_boot_para_setup(char *s)
 				hdmitx_device.cec_func_config = list;
 			hdmi_print(INF, CEC "HDMI hdmi_cec_func_config:0x%x\n",
 				   hdmitx_device.cec_func_config);
+		} else if (strcmp(token, "forcergb") == 0) {
+			hdmitx_output_rgb();
+			hdmi_print(IMP, "Forced RGB colorspace output\n");
 		}
 	}
 		offset = token_offset;
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_scdc.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_scdc.c
index e3697b7..9c7ac04 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_scdc.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_scdc.c
@@ -54,4 +54,3 @@ void scdc_config(void *hdev)
 	scdc_tmds_cfg_timer.expires = jiffies + HZ;
 	mod_timer(&scdc_tmds_cfg_timer, jiffies + HZ);
 }
-
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c
index f401755..d2bb86b 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hdmi_tx_video.c
@@ -432,7 +432,193 @@ static struct hdmitx_vidpara hdmi_tx_video_params[] = {
 		.ss		= SS_SCAN_UNDER,
 		.sc		= SC_SCALE_HORIZ_VERT,
 	},
-
+	{
+		.VIC		= HDMIV_640x480p60hz,
+		.color_prefer	= COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio	= TV_ASPECT_RATIO_4_3,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_800x480p60hz,
+		.color_prefer	= COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio	= TV_ASPECT_RATIO_16_9,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_800x600p60hz,
+		.color_prefer	= COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio	= TV_ASPECT_RATIO_4_3,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_1024x600p60hz,
+		.color_prefer	= COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio	= TV_ASPECT_RATIO_16_9,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_1024x768p60hz,
+		.color_prefer	= COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio	= TV_ASPECT_RATIO_4_3,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_1280x800p60hz,
+		.color_prefer	= COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio	= TV_ASPECT_RATIO_16_9,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_1280x1024p60hz,
+		.color_prefer	= COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio	= TV_ASPECT_RATIO_4_3,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_1360x768p60hz,
+		.color_prefer	= COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio	= TV_ASPECT_RATIO_16_9,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_1366x768p60hz,
+		.color_prefer	= COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio	= TV_ASPECT_RATIO_16_9,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_1440x900p60hz,
+		.color_prefer	= COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio	= TV_ASPECT_RATIO_16_9,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_1600x900p60hz,
+		.color_prefer	= COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio	= TV_ASPECT_RATIO_16_9,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_1680x1050p60hz,
+		.color_prefer	= COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio	= TV_ASPECT_RATIO_16_9,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_1920x1200p60hz,
+		.color_prefer	= COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio	= TV_ASPECT_RATIO_16_9,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_2560x1440p60hz,
+		.color_prefer   = COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio   = TV_ASPECT_RATIO_16_9,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_2560x1600p60hz,
+		.color_prefer   = COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio   = TV_ASPECT_RATIO_16_9,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_2560x1080p60hz,
+		.color_prefer   = COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio   = TV_ASPECT_RATIO_16_9,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
+	{
+		.VIC		= HDMIV_3440x1440p60hz,
+		.color_prefer   = COLOR_SPACE_RGB444,
+		.color_depth	= hdmi_color_depth_24B,
+		.bar_info	= B_BAR_VERT_HORIZ,
+		.repeat_time	= NO_REPEAT,
+		.aspect_ratio   = TV_ASPECT_RATIO_16_9,
+		.cc		= CC_ITU709,
+		.ss		= SS_SCAN_UNDER,
+		.sc		= SC_SCALE_HORIZ_VERT,
+	},
 };
 
 static struct hdmitx_vidpara *hdmi_get_video_param(
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/Makefile b/drivers/amlogic/hdmi/hdmi_tx_20/hw/Makefile
index dbaaf37..fb22a69 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/Makefile
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/Makefile
@@ -1 +1,4 @@
-obj-y	+= hdmi_tx_hw.o reg_ops.o sec_ops.o enc_cfg_hw.o hdmi_tx_cec_hw.o hdmi_tx_ddc.o hdcpVerify.o io_gxbb.o io_gxtvbb.o
+obj-y		+= hdmi_tx_hw.o reg_ops.o enc_cfg_hw.o hdmi_tx_ddc.o
+ifndef CONFIG_AML_AO_CEC
+obj-y		+= hdmi_tx_cec_hw.o
+endif
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/enc_cfg_hw.c b/drivers/amlogic/hdmi/hdmi_tx_20/hw/enc_cfg_hw.c
index ddf5dce..ea66def 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/enc_cfg_hw.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/enc_cfg_hw.c
@@ -572,6 +572,443 @@ static const struct reg_s tvregs_4k2k_smpte[] = {
 	{MREG_END_MARKER, 0},
 };
 
+static const struct reg_s tvregs_vesa_640x480p60hz[] = {
+	{P_VENC_VDAC_SETTING, 0xff,},
+
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x31F,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x20C,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0x90,},
+	{P_ENCP_VIDEO_HAVON_END, 0x30F,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x23,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x202,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x60,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x2,},
+
+	{P_ENCP_VIDEO_EN, 1,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{MREG_END_MARKER, 0}
+};
+
+static const struct reg_s tvregs_vesa_800x600p60hz[] = {
+	{P_VENC_VDAC_SETTING, 0xff,},
+
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x41F,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x273,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0xD8,},
+	{P_ENCP_VIDEO_HAVON_END, 0x3F7,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x1B,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x272,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x80,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x4,},
+
+	{P_ENCP_VIDEO_EN, 1,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{MREG_END_MARKER, 0}
+};
+
+static const struct reg_s tvregs_vesa_800x480p60hz[] = {
+	{P_ENCP_VIDEO_EN, 0},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_VENC_VDAC_SETTING, 0xff},
+
+	{P_ENCP_VIDEO_MODE, 0x4040},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x3DF},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x1F3},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0xA8},
+	{P_ENCP_VIDEO_HAVON_END, 0x3C7},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x11},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x1F0},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0},
+	{P_ENCP_VIDEO_HSO_END, 0x48},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E},
+	{P_ENCP_VIDEO_VSO_END, 0x32},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x7},
+
+	{P_ENCP_VIDEO_EN, 1},
+	{P_ENCI_VIDEO_EN, 0},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_s tvregs_vesa_1024x600p60hz[] = {
+	{P_VENC_VDAC_SETTING, 0xff,},
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x53F,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x27D,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0x128,},
+	{P_ENCP_VIDEO_HAVON_END, 0x527,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x23,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x27A,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x88,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x6,},
+
+	{P_ENCP_VIDEO_EN, 1,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{MREG_END_MARKER, 0}
+};
+
+static const struct reg_s tvregs_vesa_1024x768p60hz[] = {
+	{P_VENC_VDAC_SETTING, 0xff,},
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x53F,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x325,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0x128,},
+	{P_ENCP_VIDEO_HAVON_END, 0x527,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x23,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x322,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x88,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x6,},
+
+	{P_ENCP_VIDEO_EN, 1,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{MREG_END_MARKER, 0}
+};
+
+static const struct reg_s tvregs_vesa_1280x800p60hz[] = {
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{P_VENC_VDAC_SETTING, 0xff,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x59F,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x336,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0x70,},
+	{P_ENCP_VIDEO_HAVON_END, 0x56F,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x14,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x333,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x20,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x6,},
+
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0}
+};
+
+static const struct reg_s tvregs_vesa_1280x1024p60hz[] = {
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{P_VENC_VDAC_SETTING, 0xff,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x697,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x429,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0x168,},
+	{P_ENCP_VIDEO_HAVON_END, 0x667,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x29,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x428,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x70,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x3,},
+
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0}
+};
+
+static const struct reg_s tvregs_vesa_1360x768p60hz[] = {
+	{P_VENC_VDAC_SETTING, 0xff,},
+
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x6FF,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x31A,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0x170,},
+	{P_ENCP_VIDEO_HAVON_END, 0x6BF,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x18,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x317,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x70,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x6,},
+
+	{P_ENCP_VIDEO_EN, 1,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{MREG_END_MARKER, 0}
+};
+
+static const struct reg_s tvregs_vesa_1366x768p60hz[] = {
+	{P_VENC_VDAC_SETTING, 0xff,},
+
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x6FF,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x31D,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0x164,},
+	{P_ENCP_VIDEO_HAVON_END, 0x6B9,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x1B,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x31A,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x8F,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x3,},
+
+	{P_ENCP_VIDEO_EN, 1,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{MREG_END_MARKER, 0}
+};
+
+static const struct reg_s tvregs_vesa_1440x900p60hz[] = {
+	{P_VENC_VDAC_SETTING, 0xff,},
+
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x76F,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x3A5,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0x180,},
+	{P_ENCP_VIDEO_HAVON_END, 0x71F,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x1F,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x3A2,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x98,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x6,},
+
+	{P_ENCP_VIDEO_EN, 1,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{MREG_END_MARKER, 0}
+};
+
+static const struct reg_s tvregs_vesa_1600x900p60hz[] = {
+	{P_VENC_VDAC_SETTING, 0xff,},
+
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x707,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x3E7,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0xB0,},
+	{P_ENCP_VIDEO_HAVON_END, 0x6EF,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x63,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x3E6,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0x50,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x3,},
+
+	{P_ENCP_VIDEO_EN, 1,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{MREG_END_MARKER, 0}
+};
+
+static const struct reg_s tvregs_vesa_1680x1050p60hz[] = {
+	{P_VENC_VDAC_SETTING, 0xff,},
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT, 0x8BF,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 0x440,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 0x1C8,},
+	{P_ENCP_VIDEO_HAVON_END, 0x857,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 0x24,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 0x43D,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0x0,},
+	{P_ENCP_VIDEO_HSO_END, 0xB0,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x6,},
+
+	{P_ENCP_VIDEO_EN, 1,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{MREG_END_MARKER, 0}
+};
+
+static const struct reg_s tvregs_vesa_1920x1200p60hz[] = {
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{P_VENC_VDAC_SETTING, 0xff,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+	{P_ENCP_VIDEO_MAX_PXCNT,   2079,},
+	{P_ENCP_VIDEO_MAX_LNCNT,   1234,},
+	{P_ENCP_VIDEO_HAVON_BEGIN,  112,},
+	{P_ENCP_VIDEO_HAVON_END,   2031,},
+	{P_ENCP_VIDEO_VAVON_BLINE,   32,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 1231,},
+	{P_ENCP_VIDEO_HSO_BEGIN,      0,},
+	{P_ENCP_VIDEO_HSO_END,       48,},
+	{P_ENCP_VIDEO_VSO_BEGIN,   0x1E,},
+	{P_ENCP_VIDEO_VSO_END,     0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE,      0,},
+	{P_ENCP_VIDEO_VSO_ELINE,      6,},
+
+	{P_ENCP_DACSEL_0, 0x0543,},
+	{P_ENCP_DACSEL_1, 0x0000,},
+	{P_ENCI_VIDEO_EN, 0},
+	{P_ENCP_VIDEO_EN, 1},
+	{MREG_END_MARKER, 0}
+};
+
+static const struct reg_s tvregs_2560x1440p60hz[] = {
+	{P_VENC_VDAC_SETTING, 0xff,},
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+
+	{P_ENCP_VIDEO_MAX_PXCNT, 2719,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1480,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 80,},
+	{P_ENCP_VIDEO_HAVON_END, 2639,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 34,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 1473,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0,},
+	{P_ENCP_VIDEO_HSO_END, 32,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x5,},
+
+	{P_ENCP_VIDEO_EN, 1,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_s tvregs_2560x1600p60hz[] = {
+	{P_VENC_VDAC_SETTING, 0xff,},
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+
+	{P_ENCP_VIDEO_MAX_PXCNT, 2719,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1645,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 80,},
+	{P_ENCP_VIDEO_HAVON_END, 2639,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 38,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 1637,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0,},
+	{P_ENCP_VIDEO_HSO_END, 32,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0x6,},
+
+	{P_ENCP_VIDEO_EN, 1,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_s tvregs_2560x1080p60hz[] = {
+	{P_VENC_VDAC_SETTING, 0xff,},
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+
+	{P_ENCP_VIDEO_MAX_PXCNT, 2783,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1110,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 96,},
+	{P_ENCP_VIDEO_HAVON_END, 2655,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 18,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 1097,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0,},
+	{P_ENCP_VIDEO_HSO_END, 64,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 0xa,},
+
+	{P_ENCP_VIDEO_EN, 1,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{MREG_END_MARKER, 0},
+};
+
+static const struct reg_s tvregs_3440x1440p60hz[] = {
+	{P_VENC_VDAC_SETTING, 0xff,},
+	{P_ENCP_VIDEO_EN, 0,},
+	{P_ENCI_VIDEO_EN, 0,},
+
+	{P_ENCP_VIDEO_MODE, 0x4040,},
+	{P_ENCP_VIDEO_MODE_ADV, 0x18,},
+
+	{P_ENCP_VIDEO_MAX_PXCNT, 3599,},
+	{P_ENCP_VIDEO_MAX_LNCNT, 1480,},
+	{P_ENCP_VIDEO_HAVON_BEGIN, 80,},
+	{P_ENCP_VIDEO_HAVON_END, 3519,},
+	{P_ENCP_VIDEO_VAVON_BLINE, 28,},
+	{P_ENCP_VIDEO_VAVON_ELINE, 1467,},
+	{P_ENCP_VIDEO_HSO_BEGIN, 0,},
+	{P_ENCP_VIDEO_HSO_END, 32,},
+	{P_ENCP_VIDEO_VSO_BEGIN, 0x1E,},
+	{P_ENCP_VIDEO_VSO_END, 0x32,},
+	{P_ENCP_VIDEO_VSO_BLINE, 0x0,},
+	{P_ENCP_VIDEO_VSO_ELINE, 10,},
+
+	{P_ENCP_VIDEO_EN, 1,},
+	{P_ENCI_VIDEO_EN, 0,},
+	{MREG_END_MARKER, 0},
+};
+
 struct vic_tvregs_set {
 	enum hdmi_vic vic;
 	const struct reg_s *reg_setting;
@@ -602,6 +1039,23 @@ static struct vic_tvregs_set tvregsTab[] = {
 	{HDMI_3840x2160p50_16x9, tvregs_4k2k_25hz},
 	{HDMI_3840x2160p60_16x9_Y420, tvregs_4k2k_30hz},
 	{HDMI_3840x2160p50_16x9_Y420, tvregs_4k2k_25hz},
+	{HDMIV_640x480p60hz, tvregs_vesa_640x480p60hz},
+	{HDMIV_800x480p60hz, tvregs_vesa_800x480p60hz},
+	{HDMIV_800x600p60hz, tvregs_vesa_800x600p60hz},
+	{HDMIV_1024x600p60hz, tvregs_vesa_1024x600p60hz},
+	{HDMIV_1024x768p60hz, tvregs_vesa_1024x768p60hz},
+	{HDMIV_1280x800p60hz, tvregs_vesa_1280x800p60hz},
+	{HDMIV_1280x1024p60hz, tvregs_vesa_1280x1024p60hz},
+	{HDMIV_1360x768p60hz, tvregs_vesa_1360x768p60hz},
+	{HDMIV_1366x768p60hz, tvregs_vesa_1366x768p60hz},
+	{HDMIV_1440x900p60hz, tvregs_vesa_1440x900p60hz},
+	{HDMIV_1600x900p60hz, tvregs_vesa_1600x900p60hz},
+	{HDMIV_1680x1050p60hz, tvregs_vesa_1680x1050p60hz},
+	{HDMIV_1920x1200p60hz, tvregs_vesa_1920x1200p60hz},
+	{HDMIV_2560x1440p60hz, tvregs_2560x1440p60hz},
+	{HDMIV_2560x1600p60hz, tvregs_2560x1600p60hz},
+	{HDMIV_2560x1080p60hz, tvregs_2560x1080p60hz},
+	{HDMIV_3440x1440p60hz, tvregs_3440x1440p60hz},
 };
 
 static inline void setreg(const struct reg_s *r)
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_cec_hw.c b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_cec_hw.c
index ef4dbbc..093ef39 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_cec_hw.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_cec_hw.c
@@ -200,6 +200,7 @@ int cec_queue_tx_msg(const unsigned char *msg, unsigned char len)
 
 	s_idx = cec_tx_msgs.send_idx;
 	q_idx = cec_tx_msgs.queue_idx;
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
 	if (s_idx == q_idx) {
 		/*
 		 * cec is slow speed device, we need wait messages send
@@ -207,6 +208,7 @@ int cec_queue_tx_msg(const unsigned char *msg, unsigned char len)
 		 */
 		cec_wake_lock();
 	}
+#endif
 	if (((q_idx + 1) & CEC_TX_MSG_BUF_MASK) == s_idx) {
 		hdmi_print(INF, CEC "tx buffer full, abort msg\n");
 		cec_hw_reset();
@@ -366,7 +368,9 @@ void tx_irq_handle(void)
 			cec_ll_trigle_tx();
 		} else {
 			hdmi_print(INF, CEC "@TX_FINISHED\n");
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
 			cec_wake_unlock();    /* unlock */
+#endif
 		}
 		break;
 
@@ -479,12 +483,14 @@ void cec_polling_online_dev(int log_addr, int *bool)
 
 }
 
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
 void hdmitx_setup_cecirq(struct hdmitx_dev *phdev)
 {
 	int r;
 	r = request_irq(phdev->irq_cec, &cec_isr_handler, IRQF_SHARED,
 		"hdmitx_cec", (void *) phdev);
 }
+#endif
 
 /* -------------------------------------------------------------------------- */
 /* AO CEC0 config */
@@ -517,7 +523,9 @@ void ao_cec_init(void)
 	cec_enable_irq();
 
 	memset(&cec_tx_msgs, 0, sizeof(struct cec_tx_msg));
+#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
 	cec_wake_unlock();
+#endif
 }
 
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c
index ba549c7..f3ee397 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_hw.c
@@ -34,7 +34,6 @@
 #include <linux/uaccess.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
-#include <linux/amlogic/cpu_version.h>
 #include <linux/amlogic/vout/vinfo.h>
 #include <linux/amlogic/vout/enc_clk_config.h>
 #ifdef CONFIG_PANEL_IT6681
@@ -53,8 +52,6 @@
 #include "../hdmi_tx_compliance.h"
 #endif
 #include "tvenc_conf.h"
-#include "common.h"
-#include "hdcpVerify.h"
 
 #define EDID_RAM_ADDR_SIZE	 (8)
 
@@ -137,56 +134,84 @@ static int hdmitx_cntl_misc(struct hdmitx_dev *hdev, unsigned cmd,
 static void digital_clk_on(unsigned char flag);
 static void digital_clk_off(unsigned char flag);
 
+/*
+ * HDMITX HPD HW related operations
+ */
+enum hpd_op {
+	HPD_INIT_DISABLE_PULLUP,
+	HPD_INIT_SET_FILTER,
+	HPD_IS_HPD_MUXED,
+	HPD_MUX_HPD,
+	HPD_UNMUX_HPD,
+	HPD_READ_HPD_GPIO,
+};
+
 static int hdmitx_hpd_hw_op(enum hpd_op cmd)
 {
-	switch (get_cpu_type()) {
-	case MESON_CPU_MAJOR_ID_GXBB:
-		return hdmitx_hpd_hw_op_gxbb(cmd);
+	int ret = 0;
+	switch (cmd) {
+	case HPD_INIT_DISABLE_PULLUP:
+		hd_set_reg_bits(P_PAD_PULL_UP_REG1, 0, 20, 1);
 		break;
-#if 0
-	case MESON_CPU_MAJOR_ID_GXTVBB:
-		return hdmitx_hpd_hw_op_gxtvbb(cmd);
+	case HPD_INIT_SET_FILTER:
+		hdmitx_wr_reg(HDMITX_TOP_HPD_FILTER,
+			((0xa << 12) | (0xa0 << 0)));
+		break;
+	case HPD_IS_HPD_MUXED:
+		ret = !!(hd_read_reg(P_PERIPHS_PIN_MUX_1) & (1 << 26));
+		break;
+	case HPD_MUX_HPD:
+/* GPIOH_5 input */
+		hd_set_reg_bits(P_PREG_PAD_GPIO1_EN_N, 1, 21, 1);
+/* clear other pinmux */
+		hd_set_reg_bits(P_PERIPHS_PIN_MUX_1, 0, 19, 1);
+		hd_set_reg_bits(P_PERIPHS_PIN_MUX_1, 1, 26, 1);
+		break;
+	case HPD_UNMUX_HPD:
+		hd_set_reg_bits(P_PERIPHS_PIN_MUX_1, 0, 26, 1);
+/* GPIOH_5 input */
+		hd_set_reg_bits(P_PREG_PAD_GPIO1_EN_N, 1, 21, 1);
+		break;
+	case HPD_READ_HPD_GPIO:
+		ret = !!(hd_read_reg(P_PREG_PAD_GPIO1_I) & (1 << 20));
 		break;
-#endif
 	default:
+		pr_info("error hpd cmd %d\n", cmd);
 		break;
 	}
-	return 0;
+	return ret;
 }
 
 int read_hpd_gpio(void)
 {
-	switch (get_cpu_type()) {
-	case MESON_CPU_MAJOR_ID_GXBB:
-		return read_hpd_gpio_gxbb();
-		break;
-#if 0
-	case MESON_CPU_MAJOR_ID_GXTVBB:
-		return read_hpd_gpio_gxtvbb();
-		break;
-#endif
-	default:
-		break;
-	}
-	return 0;
+	return !!(hd_read_reg(P_PREG_PAD_GPIO1_I) & (1 << 20));
 }
 EXPORT_SYMBOL(read_hpd_gpio);
 
 int hdmitx_ddc_hw_op(enum ddc_op cmd)
 {
-	switch (get_cpu_type()) {
-	case MESON_CPU_MAJOR_ID_GXBB:
-		return hdmitx_ddc_hw_op_gxbb(cmd);
+	int ret = 0;
+
+	switch (cmd) {
+	case DDC_INIT_DISABLE_PULL_UP_DN:
+/* Disable GPIOH_3/4 pull-up/down */
+		hd_set_reg_bits(P_PAD_PULL_UP_EN_REG1, 0, 21, 2);
+		hd_set_reg_bits(P_PAD_PULL_UP_REG1, 0, 21, 2);
 		break;
-#if 0
-	case MESON_CPU_MAJOR_ID_GXTVBB:
-		return hdmitx_ddc_hw_op_gxtvbb(cmd);
+	case DDC_MUX_DDC:
+/* GPIOH_3/4 input */
+		hd_set_reg_bits(P_PREG_PAD_GPIO1_EN_N, 3, 21, 2);
+		hd_set_reg_bits(P_PERIPHS_PIN_MUX_1, 3, 24, 2);
 		break;
-#endif
-	default:
+	case DDC_UNMUX_DDC:
+/* GPIOH_3/4 input */
+		hd_set_reg_bits(P_PREG_PAD_GPIO1_EN_N, 3, 21, 2);
+		hd_set_reg_bits(P_PERIPHS_PIN_MUX_1, 0, 24, 2);
 		break;
+	default:
+		pr_info("error ddc cmd %d\n", cmd);
 	}
-	return 0;
+	return ret;
 }
 
 #define __asmeq(x, y)  ".ifnc " x "," y " ; .err ; .endif\n\t"
@@ -225,66 +250,6 @@ int hdmitx_hdcp_opr(unsigned int val)
 			: : "r"(x0)
 		);
 	}
-	if (val == 4) {
-		register long x0 asm("x0") = 0x82000014;
-		asm volatile(
-			__asmeq("%0", "x0")
-			"smc #0\n"
-			: : "r"(x0)
-		);
-	}
-	if (val == 5) {	/* mux hdcp22 */
-		register long x0 asm("x0") = 0x82000015;
-		asm volatile(
-			__asmeq("%0", "x0")
-			"smc #0\n"
-			: : "r"(x0)
-		);
-	}
-	if (val == 6) {	/* mux hdcp14 */
-		register long x0 asm("x0") = 0x82000016;
-		asm volatile(
-			__asmeq("%0", "x0")
-			"smc #0\n"
-			: : "r"(x0)
-		);
-	}
-	if (val == 7) {
-		register long x0 asm("x0") = 0x82000017;
-		asm volatile(
-			__asmeq("%0", "x0")
-			"smc #0\n"
-			: "+r"(x0)
-		);
-		return (unsigned)(x0&0xffffffff);
-	}
-	if (val == 0xa) {
-		register long x0 asm("x0") = 0x8200001a;
-		asm volatile(
-			__asmeq("%0", "x0")
-			"smc #0\n"
-			: "+r"(x0)
-		);
-		return (unsigned)(x0&0xffffffff);
-	}
-	if (val == 0xb) {
-		register long x0 asm("x0") = 0x8200001b;
-		asm volatile(
-			__asmeq("%0", "x0")
-			"smc #0\n"
-			: "+r"(x0)
-		);
-		return (unsigned)(x0&0xffffffff);
-	}
-	if (val == 0xc) {
-		register long x0 asm("x0") = 0x8200001c;
-		asm volatile(
-			__asmeq("%0", "x0")
-			"smc #0\n"
-			: "+r"(x0)
-		);
-		return (unsigned)(x0&0xffffffff);
-	}
 	return -1;
 }
 
@@ -336,6 +301,24 @@ static struct hdmitx_clk hdmitx_clk[] = {
 		24000, 5940000, 594000, 594000, -1, 594000},
 	{HDMI_VIC_FAKE,
 		24000, 3450000, 345000, 345000, -1, 345000},
+	/* pll setting for VESA modes */
+	{HDMIV_640x480p60hz, 24000, 252000, 25200, 25200, -1, 25200},
+	{HDMIV_800x480p60hz, 24000, 297600, 29760, 29760, -1, 29760},
+	{HDMIV_800x600p60hz, 24000, 398000, 39800, 39800, -1, 39800},
+	{HDMIV_1024x600p60hz, 24000, 518300, 51830, 51830, -1, 51830},
+	{HDMIV_1024x768p60hz, 24000, 650000, 65000, 65000, -1, 65000},
+	{HDMIV_1280x800p60hz, 24000, 711000, 71100, 71100, -1, 71100},
+	{HDMIV_1280x1024p60hz, 24000, 1081700, 108170, 108170, -1, 108170},
+	{HDMIV_1360x768p60hz, 24000, 854800, 85480, 85480, -1, 85480},
+	{HDMIV_1366x768p60hz, 24000, 858000, 85800, 85800, -1, 85800},
+	{HDMIV_1440x900p60hz, 24000, 1067000, 106700, 106700, -1, 106700},
+	{HDMIV_1600x900p60hz, 24000, 1080000, 108000, 108000, -1, 108000},
+	{HDMIV_1680x1050p60hz, 24000, 1463600, 146360, 146360, -1, 146360},
+	{HDMIV_1920x1200p60hz, 24000, 1540000, 154000, 154000, -1, 154000},
+	{HDMIV_2560x1440p60hz, 24000, 2415000, 241500, 241500, -1, 241500},
+	{HDMIV_2560x1600p60hz, 24000, 2685000, 268500, 268500, -1, 268500},
+	{HDMIV_2560x1080p60hz, 24000, 1855800, 185580, 185580, -1, 185580},
+	{HDMIV_3440x1440p60hz, 24000, 3197500, 319750, 319750, -1, 319750},
 };
 
 static void set_vmode_clk(struct hdmitx_dev *hdev, enum hdmi_vic vic)
@@ -491,7 +474,7 @@ static irqreturn_t intr_handler(int irq, void *dev)
 	if (hdev->hpd_lock == 1) {
 		hdmitx_wr_reg(HDMITX_TOP_INTR_STAT_CLR, 0xf);
 		hdmi_print(IMP, HPD "HDMI hpd locked\n");
-		goto next;
+		return IRQ_HANDLED;
 	}
 	/* check HPD status */
 	if ((data32 & (1 << 1)) && (data32 & (1 << 2))) {
@@ -500,6 +483,14 @@ static irqreturn_t intr_handler(int irq, void *dev)
 		else
 			data32 &= ~(1 << 1);
 	}
+
+	/* internal interrupt */
+	if (data32 & (1 << 0)) {
+		hdev->hdmitx_event |= HDMI_TX_INTERNAL_INTR;
+		PREPARE_WORK(&hdev->work_internal_intr,
+			hdmitx_internal_intr_handler);
+		queue_work(hdev->hdmi_wq, &hdev->work_internal_intr);
+	}
 	/* HPD rising */
 	if (data32 & (1 << 1)) {
 		hdev->hdmitx_event |= HDMI_TX_HPD_PLUGIN;
@@ -518,38 +509,6 @@ static irqreturn_t intr_handler(int irq, void *dev)
 		queue_delayed_work(hdev->hdmi_wq,
 			&hdev->work_hpd_plugout, 0);
 	}
-next:
-	/* internal interrupt */
-	if (data32 & (1 << 0)) {
-		hdev->hdmitx_event |= HDMI_TX_INTERNAL_INTR;
-		PREPARE_WORK(&hdev->work_internal_intr,
-			hdmitx_internal_intr_handler);
-		queue_work(hdev->hdmi_wq, &hdev->work_internal_intr);
-	}
-	if (data32 & (1 << 3)) {
-		unsigned int rd_nonce_mode =
-			hdmitx_rd_reg(HDMITX_TOP_SKP_CNTL_STAT) & 0x1;
-		pr_info("hdcp22: Nonce %s  Vld: %d\n",
-			rd_nonce_mode ? "HW" : "SW",
-			((hdmitx_rd_reg(HDMITX_TOP_SKP_CNTL_STAT) >> 31) & 1));
-		if (rd_nonce_mode)
-			hdmitx_wr_reg(HDMITX_TOP_INTR_STAT_CLR, (1 << 3));
-		else {
-			hdmitx_wr_reg(HDMITX_TOP_NONCE_0,  0x32107654);
-			hdmitx_wr_reg(HDMITX_TOP_NONCE_1,  0xba98fedc);
-			hdmitx_wr_reg(HDMITX_TOP_NONCE_2,  0xcdef89ab);
-			hdmitx_wr_reg(HDMITX_TOP_NONCE_3,  0x45670123);
-			hdmitx_wr_reg(HDMITX_TOP_NONCE_0,  0x76543210);
-			hdmitx_wr_reg(HDMITX_TOP_NONCE_1,  0xfedcba98);
-			hdmitx_wr_reg(HDMITX_TOP_NONCE_2,  0x89abcdef);
-			hdmitx_wr_reg(HDMITX_TOP_NONCE_3,  0x01234567);
-		}
-	}
-	if (data32 & (1 << 30)) {
-		pr_info("hdcp22: reg stat: 0x%x\n",
-			hdmitx_rd_reg(HDMITX_DWC_HDCP22REG_STAT));
-		hdmitx_wr_reg(HDMITX_DWC_HDCP22REG_STAT, 0xff);
-	}
 	hdmitx_wr_reg(HDMITX_TOP_INTR_STAT_CLR, data32 | 0x6);
 	return IRQ_HANDLED;
 }
@@ -1311,6 +1270,275 @@ static void hdmi_tvenc_set(struct hdmitx_vidpara *param)
 		SOF_LINES = 36;
 		TOTAL_FRAMES = 4;
 		break;
+	case HDMIV_640x480p60hz:
+		INTERLACE_MODE     = 0;
+		PIXEL_REPEAT_VENC  = 0;
+		PIXEL_REPEAT_HDMI  = 0;
+		ACTIVE_PIXELS      = 640;
+		ACTIVE_LINES       = 480;
+		LINES_F0           = 525;
+		LINES_F1           = 525;
+		FRONT_PORCH        = 16;
+		HSYNC_PIXELS       = 96;
+		BACK_PORCH         = 48;
+		EOF_LINES          = 10;
+		VSYNC_LINES        = 2;
+		SOF_LINES          = 33;
+		TOTAL_FRAMES       = 4;
+		break;
+	case HDMIV_800x600p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 800;
+		ACTIVE_LINES        = 600;
+		LINES_F0            = 628;
+		LINES_F1            = 628;
+		FRONT_PORCH         = 40;
+		HSYNC_PIXELS        = 128;
+		BACK_PORCH          = 88;
+		EOF_LINES           = 1;
+		VSYNC_LINES         = 4;
+		SOF_LINES           = 23;
+		TOTAL_FRAMES        = 4;
+		break;
+	case HDMIV_800x480p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 800;
+		ACTIVE_LINES        = 480;
+		LINES_F0            = 500;
+		LINES_F1            = 500;
+		FRONT_PORCH         = 24;
+		HSYNC_PIXELS        = 72;
+		BACK_PORCH          = 96;
+		EOF_LINES           = 3;
+		VSYNC_LINES         = 7;
+		SOF_LINES           = 10;
+		TOTAL_FRAMES        = 4;
+		break;
+	case HDMIV_1024x600p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 1024;
+		ACTIVE_LINES        = 600;
+		LINES_F0            = 638;
+		LINES_F1            = 638;
+		FRONT_PORCH         = 24;
+		HSYNC_PIXELS        = 136;
+		BACK_PORCH          = 160;
+		EOF_LINES           = 3;
+		VSYNC_LINES         = 6;
+		SOF_LINES           = 29;
+		TOTAL_FRAMES        = 4;
+		break;
+	case HDMIV_1024x768p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 1024;
+		ACTIVE_LINES        = 768;
+		LINES_F0            = 806;
+		LINES_F1            = 806;
+		FRONT_PORCH         = 24;
+		HSYNC_PIXELS        = 136;
+		BACK_PORCH          = 160;
+		EOF_LINES           = 3;
+		VSYNC_LINES         = 6;
+		SOF_LINES           = 29;
+		TOTAL_FRAMES        = 4;
+		break;
+	case HDMIV_1280x800p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 1280;
+		ACTIVE_LINES        = 800;
+		LINES_F0            = 823;
+		LINES_F1            = 823;
+		FRONT_PORCH         = 48;
+		HSYNC_PIXELS        = 32;
+		BACK_PORCH          = 80;
+		EOF_LINES           = 3;
+		VSYNC_LINES         = 6;
+		SOF_LINES           = 14;
+		break;
+	case HDMIV_1280x1024p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 1280;
+		ACTIVE_LINES        = 1024;
+		LINES_F0            = 1066;
+		LINES_F1            = 1066;
+		FRONT_PORCH         = 48;
+		HSYNC_PIXELS        = 112;
+		BACK_PORCH          = 248;
+		EOF_LINES           = 1;
+		VSYNC_LINES         = 3;
+		SOF_LINES           = 38;
+		break;
+	case HDMIV_1360x768p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 1360;
+		ACTIVE_LINES        = 768;
+		LINES_F0            = 795;
+		LINES_F1            = 795;
+		FRONT_PORCH         = 64;
+		HSYNC_PIXELS        = 112;
+		BACK_PORCH          = 256;
+		EOF_LINES           = 3;
+		VSYNC_LINES         = 6;
+		SOF_LINES           = 18;
+		TOTAL_FRAMES        = 4;
+		break;
+	case HDMIV_1366x768p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 1366;
+		ACTIVE_LINES        = 768;
+		LINES_F0            = 798;
+		LINES_F1            = 798;
+		FRONT_PORCH         = 70;
+		HSYNC_PIXELS        = 143;
+		BACK_PORCH          = 213;
+		EOF_LINES           = 3;
+		VSYNC_LINES         = 3;
+		SOF_LINES           = 24;
+		TOTAL_FRAMES        = 4;
+		break;
+	case HDMIV_1440x900p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 1440;
+		ACTIVE_LINES        = 900;
+		LINES_F0            = 934;
+		LINES_F1            = 934;
+		FRONT_PORCH         = 80;
+		HSYNC_PIXELS        = 152;
+		BACK_PORCH          = 232;
+		EOF_LINES           = 3;
+		VSYNC_LINES         = 6;
+		SOF_LINES           = 25;
+		TOTAL_FRAMES        = 4;
+		break;
+	case HDMIV_1600x900p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 1600;
+		ACTIVE_LINES        = 900;
+		LINES_F0            = 1800;
+		LINES_F1            = 1800;
+		FRONT_PORCH         = 24;
+		HSYNC_PIXELS        = 80;
+		BACK_PORCH          = 96;
+		EOF_LINES           = 1;
+		VSYNC_LINES         = 3;
+		SOF_LINES           = 96;
+		TOTAL_FRAMES        = 4;
+		break;
+	case HDMIV_1680x1050p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 1680;
+		ACTIVE_LINES        = 1050;
+		LINES_F0            = 1089;
+		LINES_F1            = 1089;
+		FRONT_PORCH         = 104;
+		HSYNC_PIXELS        = 176;
+		BACK_PORCH          = 280;
+		EOF_LINES           = 3;
+		VSYNC_LINES         = 6;
+		SOF_LINES           = 30;
+		TOTAL_FRAMES        = 4;
+		break;
+	case HDMIV_1920x1200p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 1920;
+		ACTIVE_LINES        = 1200;
+		LINES_F0            = 1235;
+		LINES_F1            = 1235;
+		FRONT_PORCH         = 48;
+		HSYNC_PIXELS        = 32;
+		BACK_PORCH          = 80;
+		EOF_LINES           = 3;
+		VSYNC_LINES         = 6;
+		SOF_LINES           = 26;
+		break;
+	case HDMIV_2560x1440p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 2560;
+		ACTIVE_LINES        = 1440;
+		LINES_F0            = 1481;
+		LINES_F1            = 1481;
+		FRONT_PORCH         = 48;
+		HSYNC_PIXELS        = 32;
+		BACK_PORCH          = 80;
+		EOF_LINES           = 2;
+		VSYNC_LINES         = 5;
+		SOF_LINES           = 34;
+		TOTAL_FRAMES        = 4;
+		break;
+	case HDMIV_2560x1600p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 2560;
+		ACTIVE_LINES        = 1600;
+		LINES_F0            = 1646;
+		LINES_F1            = 1646;
+		FRONT_PORCH         = 48;
+		HSYNC_PIXELS        = 32;
+		BACK_PORCH          = 80;
+		EOF_LINES           = 2;
+		VSYNC_LINES         = 6;
+		SOF_LINES           = 38;
+		TOTAL_FRAMES        = 4;
+		break;
+	case HDMIV_2560x1080p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 2560;
+		ACTIVE_LINES        = 1080;
+		LINES_F0            = 1111;
+		LINES_F1            = 1111;
+		FRONT_PORCH         = 64;
+		HSYNC_PIXELS        = 64;
+		BACK_PORCH          = 96;
+		EOF_LINES           = 3;
+		VSYNC_LINES         = 10;
+		SOF_LINES           = 18;
+		TOTAL_FRAMES        = 4;
+		break;
+	case HDMIV_3440x1440p60hz:
+		INTERLACE_MODE      = 0;
+		PIXEL_REPEAT_VENC   = 0;
+		PIXEL_REPEAT_HDMI   = 0;
+		ACTIVE_PIXELS       = 3440;
+		ACTIVE_LINES        = 1440;
+		LINES_F0            = 1481;
+		LINES_F1            = 1481;
+		FRONT_PORCH         = 48;
+		HSYNC_PIXELS        = 32;
+		BACK_PORCH          = 80;
+		EOF_LINES           = 3;
+		VSYNC_LINES         = 10;
+		SOF_LINES           = 28;
+		TOTAL_FRAMES        = 4;
+		break;
 	default:
 		break;
 	}
@@ -1468,6 +1696,18 @@ static void hdmi_tvenc_set(struct hdmitx_vidpara *param)
 			hd_set_reg_bits(P_VPU_HDMI_SETTING, 3, 12, 4);
 		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
 		break;
+	case HDMIV_640x480p60hz:
+		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
+				(0 << 1) |
+				(0 << 2) |
+				(0 << 3) |
+				(0 << 4) |
+				(4 << 5) |
+				(0 << 8) |
+				(0 << 12)
+		);
+		hd_set_reg_bits(P_VPU_HDMI_SETTING, 1, 1, 1);
+		break;
 	case HDMI_720p60:
 	case HDMI_720p50:
 		hd_write_reg(P_VPU_HDMI_SETTING, (0 << 0) |
@@ -1792,6 +2032,7 @@ static int hdmitx_set_dispmode(struct hdmitx_dev *hdev,
 	mdelay(1);
 	hdmitx_set_reg_bits(HDMITX_DWC_FC_INVIDCONF, 1, 3, 1);
 
+
 	return 0;
 }
 
@@ -2045,25 +2286,17 @@ static void set_aud_info_pkt(struct hdmitx_dev *hdev,
 	hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF1, 0, 4, 2); /* SS */
 	switch (audio_param->type) {
 	case CT_MAT:
-	case CT_DTS_HD_MA:
 		/* CC: 8ch */
 		hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF0, 7, 4, 3);
 		hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF2, 0x13);
 		break;
-	case CT_PCM:
-		hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF0,
-			audio_param->channel_num, 4, 3);
-		if (audio_param->channel_num == 0x7)
-			hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF2, 0x13);
-		else
-			hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF2, 0x00);
-		break;
 	case CT_DTS:
 	case CT_DTS_HD:
 	default:
 		/* CC: 2ch */
 		hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDICONF0, 1, 4, 3);
 		hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF2, 0x0);
+		hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF2, 0x0);
 		break;
 	}
 	hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF3, 0);
@@ -2079,24 +2312,15 @@ static void set_aud_acr_pkt(struct hdmitx_dev *hdev,
 	/* audio packetizer config */
 	hdmitx_wr_reg(HDMITX_DWC_AUD_INPUTCLKFS, tx_aud_src ? 4 : 0);
 
-	if ((audio_param->type == CT_MAT)
-	|| (audio_param->type == CT_DTS_HD_MA))
+	if (audio_param->type == CT_MAT)
 		hdmitx_wr_reg(HDMITX_DWC_AUD_INPUTCLKFS, 2);
 
 	switch (audio_param->type) {
-	case 0: /* padding only, unused */
 	case CT_PCM:
 	case CT_AC_3:
 	case CT_DTS:
 	case CT_DTS_HD:
 		aud_n_para = 6144;
-		if ((hdev->cur_VIC == HDMI_4k2k_24) ||
-			(hdev->cur_VIC == HDMI_4k2k_25) ||
-			(hdev->cur_VIC == HDMI_4k2k_30) ||
-			(hdev->cur_VIC == HDMI_4k2k_smpte_24) ||
-			(hdev->cur_VIC == HDMI_4k2k_50_y420) ||
-			(hdev->cur_VIC == HDMI_4k2k_60_y420))
-			aud_n_para = 5120;
 		break;
 	default:
 		aud_n_para = 6144 * 4;
@@ -2145,21 +2369,12 @@ static void set_aud_samp_pkt(struct hdmitx_dev *hdev,
 {
 	switch (audio_param->type) {
 	case CT_MAT: /* HBR */
-	case CT_DTS_HD_MA:
 		hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF1, 1, 7, 1);
 		hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF1, 1, 6, 1);
 		hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF1, 24, 0, 5);
 		hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCONF, 1, 0, 1);
 		break;
 	case CT_PCM: /* AudSamp */
-		hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF1, 0, 7, 1);
-		hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF1, 0, 6, 1);
-		hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF1, 24, 0, 5);
-		if (audio_param->channel_num == 0x7)
-			hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCONF, 1, 0, 1);
-		else
-			hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCONF, 0, 0, 1);
-		break;
 	case CT_AC_3:
 	case CT_DOLBY_D:
 	case CT_DTS:
@@ -2169,7 +2384,7 @@ static void set_aud_samp_pkt(struct hdmitx_dev *hdev,
 		hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF1, 0, 6, 1);
 		hdmitx_set_reg_bits(HDMITX_DWC_AUD_SPDIF1, 24, 0, 5);
 		hdmitx_set_reg_bits(HDMITX_DWC_FC_AUDSCONF, 0, 0, 1);
-		break;
+	break;
 	}
 }
 
@@ -2205,8 +2420,7 @@ static int hdmitx_set_audmode(struct hdmitx_dev *hdev,
 		tx_aud_src = 0;
 	pr_info("hdmitx tx_aud_src = %d\n", tx_aud_src);
 
-	/* set_hdmi_audio_source(tx_aud_src ? 1 : 2); */
-	set_hdmi_audio_source(2);
+	set_hdmi_audio_source(tx_aud_src ? 1 : 2);
 
 /* config IP */
 /* Configure audio */
@@ -2289,6 +2503,7 @@ static void hdmitx_setupirq(struct hdmitx_dev *phdev)
 	r = request_irq(phdev->irq_hpd, &intr_handler,
 			IRQF_SHARED, "hdmitx",
 			(void *)phdev);
+
 }
 
 static void hdmitx_uninit(struct hdmitx_dev *phdev)
@@ -2632,7 +2847,7 @@ static void hdmitx_debug(struct hdmitx_dev *hdev, const char *buf)
 		if (i == 2)
 			pr_info("hdcp rslt = %d", hdmitx_hdcp_opr(2));
 		if (i == 1)
-			hdev->HWOp.CntlDDC(hdev, DDC_HDCP_OP, HDCP14_ON);
+			hdev->HWOp.CntlDDC(hdev, DDC_HDCP_OP, HDCP_ON);
 		return;
 	} else if (strncmp(tmpbuf, "dumpallregs", 11) == 0) {
 		hdmitx_dump_all_cvregs();
@@ -2657,13 +2872,6 @@ static void hdmitx_debug(struct hdmitx_dev *hdev, const char *buf)
 			hdmi_print(INF, HPD "hdmitx: unlock hpd\n");
 		}
 		return;
-	} else if (strncmp(tmpbuf, "hpd_stick", 9) == 0) {
-		if (tmpbuf[9] == '1')
-			hdev->hdcp_hpd_stick = 1;
-		else
-			hdev->hdcp_hpd_stick = 0;
-		pr_info("hdmitx: %sstick hpd\n",
-			(hdev->hdcp_hpd_stick) ? "" : "un");
 	} else if (strncmp(tmpbuf, "vic", 3) == 0) {
 		pr_info("hdmi vic count = %d\n", hdev->vic_count);
 		if ((tmpbuf[3] >= '0') && (tmpbuf[3] <= '9')) {
@@ -2677,37 +2885,34 @@ static void hdmitx_debug(struct hdmitx_dev *hdev, const char *buf)
 		unsigned char reg_val = 0;
 		unsigned int reg_adr = 0;
 
-#define DUMP_HDMITX_SECTION(a, b) \
-	for (reg_adr = a; reg_adr < b+1; reg_adr++) { \
-		reg_val = hdmitx_rd_reg(reg_adr); \
-		if (reg_val) \
-			pr_info("[0x%x]: 0x%x\n", reg_adr, reg_val); \
-		}
+#define DUMP_SECTION(a, b) \
+	do { \
+		for (reg_adr = a; reg_adr < b+1; reg_adr++) { \
+			reg_val = hdmitx_rd_reg(reg_adr); \
+			if (reg_val) \
+				pr_info("[0x%x]: 0x%x\n", reg_adr, reg_val); \
+		} \
+	} while (0)
 
-#define DUMP_HDMITX_HDCP_SECTION(a, b) \
+#define DUMP_HDCP_SECTION(a, b) \
 	for (reg_adr = a; reg_adr < b+1; reg_adr++) { \
 		hdmitx_wr_reg(HDMITX_DWC_A_KSVMEMCTRL, 0x1); \
 		hdmitx_poll_reg(HDMITX_DWC_A_KSVMEMCTRL, (1<<1), 2 * HZ); \
 		reg_val = hdmitx_rd_reg(reg_adr); \
 		if (reg_val) \
-			pr_info("[0x%x]: 0x%x\n", reg_adr, reg_val); \
-		}
+				pr_info("[0x%x]: 0x%x\n", reg_adr, reg_val); \
+	}
 
-		DUMP_HDMITX_SECTION(HDMITX_TOP_SW_RESET,
-			HDMITX_TOP_DONT_TOUCH1);
-		DUMP_HDMITX_SECTION(HDMITX_TOP_SKP_CNTL_STAT,
-			HDMITX_TOP_SEC_SCRATCH);
-		DUMP_HDMITX_SECTION(HDMITX_DWC_DESIGN_ID,
-			HDMITX_DWC_A_KSVMEMCTRL);
-		DUMP_HDMITX_HDCP_SECTION(HDMITX_DWC_HDCP_BSTATUS_0,
+		DUMP_SECTION(HDMITX_TOP_SW_RESET, HDMITX_TOP_DONT_TOUCH1);
+		DUMP_SECTION(HDMITX_TOP_SKP_CNTL_STAT, HDMITX_TOP_SEC_SCRATCH);
+		DUMP_SECTION(HDMITX_DWC_DESIGN_ID, HDMITX_DWC_A_KSVMEMCTRL);
+		DUMP_HDCP_SECTION(HDMITX_DWC_HDCP_BSTATUS_0,
 			HDMITX_DWC_HDCPREG_BKSV0 - 1);
-		DUMP_HDMITX_SECTION(HDMITX_DWC_HDCPREG_ANCONF,
+		DUMP_SECTION(HDMITX_DWC_HDCPREG_BKSV0,
 			HDMITX_DWC_HDCP22REG_MUTE);
-		DUMP_HDMITX_SECTION(HDMITX_DWC_A_HDCPCFG0,
-			HDMITX_DWC_A_HDCPCFG1);
-		DUMP_HDMITX_SECTION(HDMITX_DWC_HDCPREG_SEED0,
-			HDMITX_DWC_HDCPREG_DPK6);
-		DUMP_HDMITX_SECTION(HDMITX_DWC_HDCP22REG_CTRL,
+		DUMP_SECTION(HDMITX_DWC_A_HDCPCFG0, HDMITX_DWC_A_HDCPCFG1);
+		DUMP_SECTION(HDMITX_DWC_HDCPREG_SEED0, HDMITX_DWC_HDCPREG_DPK6);
+		DUMP_SECTION(HDMITX_DWC_HDCP22REG_CTRL,
 			HDMITX_DWC_HDCP22REG_CTRL);
 		return;
 	} else if (strncmp(tmpbuf, "dumpcecreg", 10) == 0) {
@@ -2826,10 +3031,6 @@ static void hdmitx_debug(struct hdmitx_dev *hdev, const char *buf)
 			hdmitx_wr_reg((unsigned int)adr, (unsigned int)value);
 			read_back = hdmitx_rd_reg(adr);
 		}
-		if (buf[1] == 'c') {
-			hdcp22_wr_reg((uint32_t)adr, (uint32_t)value);
-			read_back = hdcp22_rd_reg((uint32_t)adr);
-		}
 		hdmi_print(INF, "write %x to %s reg[%x]\n", value, "HDMI", adr);
 /* Add read back function in order to judge writting is OK or NG. */
 		hdmi_print(INF, "Read Back %s reg[%x]=%x\n", "HDMI",
@@ -2838,8 +3039,6 @@ static void hdmitx_debug(struct hdmitx_dev *hdev, const char *buf)
 		ret = kstrtoul(tmpbuf+2, 16, &adr);
 		if (buf[1] == 'h')
 			value = hdmitx_rd_reg(adr);
-		if (buf[1] == 'c')
-			value = hdcp22_rd_reg((uint32_t)adr);
 		hdmi_print(INF, "%s reg[%x]=%x\n", "HDMI", adr, value);
 	} else if (strncmp(tmpbuf, "gpio_i2c_on", 11) == 0) {
 		hdev->gpio_i2c_enable = 1;
@@ -2875,19 +3074,17 @@ static void hdmitx_read_edid(unsigned char *rx_edid)
 	unsigned int byte_num = 0;
 	unsigned char   blk_no = 1;
 
-	/* Program SLAVE/ADDR */
+	/* Program SLAVE/SEGMENT/ADDR */
 	hdmitx_wr_reg(HDMITX_DWC_I2CM_SLAVE, 0x50);
+	hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGADDR,  0x30);
 	/* Read complete EDID data sequentially */
 	while (byte_num < 128 * blk_no) {
+		if ((byte_num % 256) == 0)
+			hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGPTR, byte_num>>8);
 		hdmitx_wr_reg(HDMITX_DWC_I2CM_ADDRESS,  byte_num&0xff);
-		if (((byte_num == 256) || (byte_num == 384)) && (blk_no > 2)) {
-			/* Program SEGMENT/SEGPTR */
-			hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGADDR, 0x30);
-			hdmitx_wr_reg(HDMITX_DWC_I2CM_SEGPTR, 0x1);
-			hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1<<3);
-		} else
-			hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1<<2);
-		/* Wait until I2C done */
+	/* Do extended sequential read */
+		hdmitx_wr_reg(HDMITX_DWC_I2CM_OPERATION, 1<<3);
+	/* Wait until I2C done */
 		timeout = 0;
 		while ((!(hdmitx_rd_reg(HDMITX_DWC_IH_I2CM_STAT0) & (1 << 1)))
 			&& (timeout < 3)) {
@@ -2897,12 +3094,12 @@ static void hdmitx_read_edid(unsigned char *rx_edid)
 		if (timeout == 3)
 			pr_info("hdmitx: ddc timeout\n");
 		hdmitx_wr_reg(HDMITX_DWC_IH_I2CM_STAT0, 1 << 1);
-		/* Read back 8 bytes */
+	/* Read back 8 bytes */
 		for (i = 0; i < 8; i++) {
 			rx_edid[byte_num] =
 				hdmitx_rd_reg(HDMITX_DWC_I2CM_READ_BUFF0 + i);
 			if (byte_num == 126) {
-				blk_no = rx_edid[126] + 1;
+				blk_no = rx_edid[byte_num] + 1;
 				if (blk_no > 4) {
 					pr_info("edid extension block number:");
 					pr_info(" %d, reset to MAX 3\n",
@@ -2910,59 +3107,13 @@ static void hdmitx_read_edid(unsigned char *rx_edid)
 					blk_no = 4; /* Max extended block */
 				}
 			}
-			byte_num++;
+		byte_num++;
 		}
 	}
 } /* hdmi20_tx_read_edid */
 
 static unsigned char tmp_edid_buf[128*EDID_MAX_BLOCK] = { 0 };
 
-#define HDCP_NMOOFDEVICES 127
-
-static uint8_t *hdcp_mKsvListBuf;
-static void hdcp_ksv_sha1_calc(struct hdmitx_dev *hdev)
-{
-	size_t list = 0;
-	size_t size = 0;
-	size_t i = 0;
-	int valid = HDCP_IDLE;
-
-	/* 0x165e: Page 95 */
-	hdcp_mKsvListBuf = kmalloc(0x1660, GFP_KERNEL);
-	if (hdcp_mKsvListBuf) {
-		/* KSV_LEN; */
-		list = hdmitx_rd_reg(HDMITX_DWC_HDCP_BSTATUS_0) & KSV_MSK;
-		if (list <= HDCP_NMOOFDEVICES) {
-			size = (list * KSV_LEN) + HEADER + SHAMAX;
-			for (i = 0; i < size; i++) {
-				if (i < HEADER) { /* BSTATUS & M0 */
-					hdcp_mKsvListBuf[(list * KSV_LEN) + i]
-						= hdmitx_rd_reg(
-						HDMITX_DWC_HDCP_BSTATUS_0 + i);
-				} else if (i < (HEADER + (list * KSV_LEN))) {
-					/* KSV list */
-					hdcp_mKsvListBuf[i - HEADER] =
-						hdmitx_rd_reg(
-						HDMITX_DWC_HDCP_BSTATUS_0 + i);
-				} else { /* SHA */
-					hdcp_mKsvListBuf[i] = hdmitx_rd_reg(
-						HDMITX_DWC_HDCP_BSTATUS_0 + i);
-				}
-			}
-			valid = hdcpVerify_KSV(hdcp_mKsvListBuf, size)
-				== TRUE	? HDCP_KSV_LIST_READY :
-				HDCP_ERR_KSV_LIST_NOT_VALID;
-		}
-		hdmitx_set_reg_bits(HDMITX_DWC_A_KSVMEMCTRL, 0, 0, 1);
-		hdmitx_set_reg_bits(HDMITX_DWC_A_KSVMEMCTRL,
-			(valid == HDCP_KSV_LIST_READY) ? 0 : 1, 3, 1);
-		hdmitx_set_reg_bits(HDMITX_DWC_A_KSVMEMCTRL, 1, 2, 1);
-		hdmitx_set_reg_bits(HDMITX_DWC_A_KSVMEMCTRL, 0, 2, 1);
-		kfree(hdcp_mKsvListBuf);
-	} else
-		pr_info("hdcptx14: KSV List memory not valid\n");
-}
-
 static void hdcp_ksv_event(unsigned long arg)
 {
 	struct hdmitx_dev *hdev = (struct hdmitx_dev *)arg;
@@ -2974,14 +3125,6 @@ static void hdcp_ksv_event(unsigned long arg)
 	}
 	if (hdmitx_rd_reg(HDMITX_DWC_A_APIINTSTAT) & (1 << 1)) {
 		hdmitx_wr_reg(HDMITX_DWC_A_APIINTCLR, (1 << 1));
-		hdmitx_wr_reg(HDMITX_DWC_A_KSVMEMCTRL, 0x1);
-		hdmitx_poll_reg(HDMITX_DWC_A_KSVMEMCTRL, (1<<1), 2 * HZ);
-		if (hdmitx_rd_reg(HDMITX_DWC_A_KSVMEMCTRL) & (1 << 1)) {
-			hdcp_ksv_sha1_calc(hdev);
-		} else {
-			pr_info("hdcptx14: KSV List memory access denied\n");
-			return;
-		}
 		hdmitx_wr_reg(HDMITX_DWC_A_KSVMEMCTRL, 0x4);
 	}
 	if (hdev->hdcp_try_times)
@@ -3014,7 +3157,7 @@ static int hdmitx_cntl_ddc(struct hdmitx_dev *hdev, unsigned cmd,
 	unsigned long argv)
 {
 	int i = 0;
-
+	static int hdcp_already_on;
 	unsigned char *tmp_char = NULL;
 	if (!(cmd & CMD_DDC_OFFSET))
 		hdmi_print(ERR, "ddc: " "w: invalid cmd 0x%x\n", cmd);
@@ -3051,29 +3194,19 @@ static int hdmitx_cntl_ddc(struct hdmitx_dev *hdev, unsigned cmd,
 	case DDC_RESET_HDCP:
 
 		break;
-	case DDC_HDCP_MUX_INIT:
-		if (argv == 2)
-			; /* hdmitx_hdcp_opr(5); */
-		if (argv == 1)
-			hdmitx_hdcp_opr(6);
-		break;
 	case DDC_HDCP_OP:
-		if (argv == HDCP14_ON) {
-			hdmitx_ddc_hw_op(DDC_MUX_DDC);
-			hdmitx_set_reg_bits(HDMITX_DWC_MC_CLKDIS, 0, 6, 1);
-			hdmitx_hdcp_opr(6);
-			hdmitx_hdcp_opr(1);
-			hdcp_start_timer(hdev);
+		if (argv == HDCP_ON) {
+			if (!hdcp_already_on) {
+				hdcp_already_on = 1;
+				hdmitx_ddc_hw_op(DDC_MUX_DDC);
+				hdmitx_hdcp_opr(1);
+				hdcp_start_timer(hdev);
+			}
 		}
-		if (argv == HDCP14_OFF)
-			hdmitx_hdcp_opr(4);
-		if (argv == HDCP22_ON) {
-			hdmitx_ddc_hw_op(DDC_MUX_DDC);
-			hdmitx_hdcp_opr(5);
-			/* wait for start hdcp22app */
+		if (argv == HDCP_OFF) {
+			hdcp_already_on = 0;
+			hdmitx_set_reg_bits(HDMITX_DWC_MC_CLKDIS, 1, 6, 1);
 		}
-		if (argv == HDCP22_OFF)
-			hdmitx_hdcp_opr(6);
 		break;
 	case DDC_IS_HDCP_ON:
 /* argv = !!((hdmitx_rd_reg(TX_HDCP_MODE)) & (1 << 7)); */
@@ -3085,21 +3218,7 @@ static int hdmitx_cntl_ddc(struct hdmitx_dev *hdev, unsigned cmd,
 				hdmitx_rd_reg(HDMITX_DWC_HDCPREG_BKSV0 + 4 - i);
 		break;
 	case DDC_HDCP_GET_AUTH:
-		if (hdev->hdcp_mode == 1)
-			return hdmitx_hdcp_opr(2);
-		if (hdev->hdcp_mode == 2)
-			return hdmitx_hdcp_opr(7);
-		else
-			return 0;
-		break;
-	case DDC_HDCP_14_LSTORE:
-		return hdmitx_hdcp_opr(0xa);
-		break;
-	case DDC_HDCP_22_LSTORE:
-		return hdmitx_hdcp_opr(0xb);
-		break;
-	case DDC_HDCP_BYP:
-		hdmitx_set_reg_bits(HDMITX_DWC_MC_CLKDIS, 1, 6, 1);
+		return hdmitx_hdcp_opr(2);
 		break;
 	default:
 		hdmi_print(INF, "ddc: " "unknown cmd: 0x%x\n", cmd);
@@ -3343,13 +3462,6 @@ static int hdmitx_cntl_misc(struct hdmitx_dev *hdev, unsigned cmd,
 		if (argv == TMDS_PHY_DISABLE)
 			hdmi_phy_suspend();
 		break;
-	case MISC_ESM_RESET:
-		if (hdev->hdcp_hpd_stick == 1) {
-			pr_info("hdcp: stick mode\n");
-			break;
-		}
-		hdmitx_hdcp_opr(6);
-		break;
 	case MISC_VIID_IS_USING:
 		break;
 	case MISC_CONF_MODE420:
@@ -3397,9 +3509,6 @@ static int hdmitx_cntl_misc(struct hdmitx_dev *hdev, unsigned cmd,
 		}
 		break;
 #endif
-	case MISC_HDCP_CLKDIS:
-		hdmitx_set_reg_bits(HDMITX_DWC_MC_CLKDIS, argv, 6, 1);
-		break;
 	default:
 		hdmi_print(ERR, "misc: " "hdmitx: unknown cmd: 0x%x\n", cmd);
 	}
@@ -3582,7 +3691,7 @@ static void config_hdmi20_tx(enum hdmi_vic vic,
  * until later enable by test.c
  */
 	data32  = 0;
-	data32 |= (0 << 6);
+	data32 |= (1 << 6);
 	data32 |= (0 << 5);
 	data32 |= (0 << 4);
 	data32 |= (0 << 3);
@@ -3857,6 +3966,13 @@ static void config_hdmi20_tx(enum hdmi_vic vic,
 	hdmitx_wr_reg(HDMITX_DWC_FC_AVICONF3,   data32);
 
 	hdmitx_wr_reg(HDMITX_DWC_FC_AVIVID, (para->vic & HDMITX_VIC_MASK));
+	/* For VESA modes, set VIC as 0 */
+	/*
+	if (para->vic >= HDMITX_VESA_OFFSET) {
+		hdmitx_wr_reg(HDMITX_DWC_FC_AVIVID, 0);
+		hd_write_reg(P_ISA_DEBUG_REG0, para->vic);
+	}
+	*/
 
 	/* write Audio Infoframe packet configuration */
 
@@ -3870,7 +3986,7 @@ static void config_hdmi20_tx(enum hdmi_vic vic,
 	data32 |= (0 << 0);
 	hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF1, data32);
 
-	hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF2, 0x00);
+	hdmitx_wr_reg(HDMITX_DWC_FC_AUDICONF2, 0x13);
 
 	data32  = 0;
 	data32 |= (1 << 5);
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_reg.h b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_reg.h
index 00d777f..3c9ac03 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_reg.h
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/hdmi_tx_reg.h
@@ -31,9 +31,6 @@ void hdmitx_rd_check_reg(unsigned int addr, unsigned int exp_data,
 	unsigned int mask);
 unsigned long aocec_rd_reg(unsigned long addr);
 void aocec_wr_reg(unsigned long addr, unsigned long data);
-void hdcp22_wr_reg(uint32_t addr, uint32_t data);
-uint32_t hdcp22_rd_reg(uint32_t addr);
-int hdmitx_hdcp_opr(unsigned int val);
 
 /* TOP-level wrapper registers addresses */
 /* bit24: 1 means secure access */
@@ -888,7 +885,6 @@ int hdmitx_hdcp_opr(unsigned int val);
 #define HDMITX_DWC_HDCP_REVOC_SIZE_0            (DWC_OFFSET_MASK + 0x52B9)
 #define HDMITX_DWC_HDCP_REVOC_SIZE_1            (DWC_OFFSET_MASK + 0x52BA)
 #define HDMITX_DWC_HDCP_REVOC_LIST              (DWC_OFFSET_MASK + 0x52BB)
-#define HDMITX_DWC_HDCP_REVOC_LIST_END          (DWC_OFFSET_MASK + 0x667E)
 
 /* HDCP BKSV Registers */
 #define HDMITX_DWC_HDCPREG_BKSV0                (DWC_OFFSET_MASK + 0x7800)
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/mach_reg.h b/drivers/amlogic/hdmi/hdmi_tx_20/hw/mach_reg.h
index 259a152..2aa41ee 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/mach_reg.h
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/mach_reg.h
@@ -796,5 +796,4 @@ void init_reg_map(void);
 #define P_HDMITX_DATA_PORT        0xc883a004
 #define P_HDMITX_CTRL_PORT        0xc883a008
 
-#define P_ELP_ESM_HPI_REG_BASE		0xd0044000
 #endif
diff --git a/drivers/amlogic/hdmi/hdmi_tx_20/hw/reg_ops.c b/drivers/amlogic/hdmi/hdmi_tx_20/hw/reg_ops.c
index ac74bfa..4132cd4 100644
--- a/drivers/amlogic/hdmi/hdmi_tx_20/hw/reg_ops.c
+++ b/drivers/amlogic/hdmi/hdmi_tx_20/hw/reg_ops.c
@@ -33,7 +33,9 @@
 #include "hdmi_tx_reg.h"
 
 static int dbg_en;
+#ifndef CONFIG_AML_AO_CEC
 static DEFINE_SPINLOCK(reg_lock2);
+#endif
 
 /*
  * RePacket HDMI related registers rd/wr
@@ -191,27 +193,17 @@ unsigned int hdmitx_rd_reg(unsigned int addr)
 	unsigned long offset = (addr & DWC_OFFSET_MASK) >> 24;
 	unsigned long flags, fiq_flag;
 	if (addr & SEC_OFFSET) {
-		addr = addr & 0xffff;
-		sec_reg_write((unsigned *)(unsigned long)
-			(P_HDMITX_ADDR_PORT_SEC + offset), addr);
-		sec_reg_write((unsigned *)(unsigned long)
-			(P_HDMITX_ADDR_PORT_SEC + offset), addr);
-		data = sec_reg_read((unsigned *)(unsigned long)
-			(P_HDMITX_DATA_PORT_SEC + offset));
+		/* TODO */
+		/* LEAVE FOR LATER */
 	} else {
 		addr = addr & 0xffff;
 		spin_lock_irqsave(&reg_lock, flags);
 		raw_local_save_flags(fiq_flag);
 		local_fiq_disable();
 
-/*
- * If addr is located at 0x5020 ~ 0x667e in DWC,
- * then should operate twice
- */
 		hd_write_reg(P_HDMITX_ADDR_PORT + offset, addr);
 		hd_write_reg(P_HDMITX_ADDR_PORT + offset, addr);
 		data = hd_read_reg(P_HDMITX_DATA_PORT + offset);
-		data = hd_read_reg(P_HDMITX_DATA_PORT + offset);
 
 		raw_local_irq_restore(fiq_flag);
 		spin_unlock_irqrestore(&reg_lock, flags);
@@ -228,13 +220,8 @@ void hdmitx_wr_reg(unsigned int addr, unsigned int data)
 	unsigned long offset = (addr & DWC_OFFSET_MASK) >> 24;
 
 	if (addr & SEC_OFFSET) {
-		addr = addr & 0xffff;
-		sec_reg_write((unsigned *)(unsigned long)
-			(P_HDMITX_ADDR_PORT_SEC + offset), addr);
-		sec_reg_write((unsigned *)(unsigned long)
-			(P_HDMITX_ADDR_PORT_SEC + offset), addr);
-		sec_reg_write((unsigned *)(unsigned long)
-			(P_HDMITX_DATA_PORT_SEC + offset), data);
+		/* TODO */
+		/* LEAVE FOR LATER */
 	} else {
 		addr = addr & 0xffff;
 		spin_lock_irqsave(&reg_lock, flags);
@@ -301,6 +288,7 @@ void hdmitx_rd_check_reg(unsigned int addr, unsigned int exp_data,
 		} \
 	} while (0)
 
+#ifndef CONFIG_AML_AO_CEC
 unsigned long aocec_rd_reg(unsigned long addr)
 {
 	unsigned long data32;
@@ -332,18 +320,8 @@ void aocec_wr_reg(unsigned long addr, unsigned long data)
 	hd_write_reg(P_AO_CEC_RW_REG, data32);
 	spin_unlock_irqrestore(&reg_lock2, flags);
 } /* aocec_wr_only_reg */
+#endif
 
-void hdcp22_wr_reg(uint32_t addr, uint32_t data)
-{
-	sec_reg_write((unsigned *)(unsigned long)
-		(P_ELP_ESM_HPI_REG_BASE + addr), data);
-}
-
-uint32_t hdcp22_rd_reg(uint32_t addr)
-{
-	return (uint32_t)sec_reg_read((unsigned *)(unsigned long)
-		(P_ELP_ESM_HPI_REG_BASE + addr));
-}
 
 MODULE_PARM_DESC(dbg_en, "\n debug_level\n");
 module_param(dbg_en, int, 0664);
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_common.h b/include/linux/amlogic/hdmi_tx/hdmi_common.h
index 783e991..3857022 100644
--- a/include/linux/amlogic/hdmi_tx/hdmi_common.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_common.h
@@ -24,6 +24,7 @@
 	VIC_MAX_VALID_MODE and VIC_MAX_NUM in hdmi_tx_module.h */
 #define HDMITX_VIC420_OFFSET	0x100
 #define HDMITX_VIC420_FAKE_OFFSET 0x200
+#define HDMITX_VESA_OFFSET	0x300
 
 #define HDMITX_VIC_MASK			0xff
 
@@ -166,6 +167,24 @@ enum hdmi_vic {
 	HDMI_VIC_Y420_MAX,
 
 	HDMI_VIC_FAKE = HDMITX_VIC420_FAKE_OFFSET,
+
+	HDMIV_640x480p60hz = HDMITX_VESA_OFFSET,
+	HDMIV_800x480p60hz,
+	HDMIV_800x600p60hz,
+	HDMIV_1024x600p60hz,
+	HDMIV_1024x768p60hz,
+	HDMIV_1280x800p60hz,
+	HDMIV_1280x1024p60hz,
+	HDMIV_1360x768p60hz,
+	HDMIV_1366x768p60hz,
+	HDMIV_1440x900p60hz,
+	HDMIV_1600x900p60hz,
+	HDMIV_1680x1050p60hz,
+	HDMIV_1920x1200p60hz,
+	HDMIV_2560x1440p60hz,
+	HDMIV_2560x1600p60hz,
+	HDMIV_2560x1080p60hz,
+	HDMIV_3440x1440p60hz,
 };
 
 /* Compliance with old definitions */
@@ -333,8 +352,6 @@ unsigned int hdmi_get_csc_coef(
 
 /* HDMI Audio Parmeters */
 /* Refer to CEA-861-D Page 88 */
-#define DTS_HD_TYPE_MASK 0xff00
-#define DTS_HD_MA  (0X1 << 8)
 enum hdmi_audio_type {
 	CT_REFER_TO_STREAM = 0,
 	CT_PCM,
@@ -351,7 +368,6 @@ enum hdmi_audio_type {
 	CT_MAT, /* TrueHD */
 	CT_DST,
 	CT_WMA,
-	CT_DTS_HD_MA = CT_DTS_HD + (DTS_HD_MA),
 	CT_MAX,
 };
 
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h b/include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h
index 1d1ce47..746e8a3 100644
--- a/include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h
@@ -442,6 +442,7 @@ struct cec_global_info_t {
 	struct cec_node_info_t cec_node_info[MAX_NUM_OF_DEV];
 	struct cec_rx_msg_buf_t cec_rx_msg_buf;
 	struct hdmitx_dev *hdmitx_device;
+	enum cec_power_status_e tv_power_status;
 };
 
 struct cec_global_info_to_usr_t {
@@ -618,6 +619,8 @@ void cec_send_event(struct cec_rx_message_t *pcec_message);
 void cec_user_control_pressed(struct cec_rx_message_t *pcec_message);
 void cec_user_control_released(struct cec_rx_message_t *pcec_message);
 void cec_standby(struct cec_rx_message_t *pcec_message);
+void cec_send_simplink_alive(struct cec_rx_message_t *pcec_message);
+void cec_send_simplink_ack(struct cec_rx_message_t *pcec_message);
 
 extern void cec_key_init(void);
 extern __u16 cec_key_map[];
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_tx_cec_20.h b/include/linux/amlogic/hdmi_tx/hdmi_tx_cec_20.h
new file mode 100644
index 0000000..f7f34e6
--- /dev/null
+++ b/include/linux/amlogic/hdmi_tx/hdmi_tx_cec_20.h
@@ -0,0 +1,361 @@
+/*
+ * include/linux/amlogic/hdmi_tx/hdmi_tx_cec.h
+ *
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+
+#ifndef _TX_CEC_H_
+#define _TX_CEC_H_
+
+#include <linux/irq.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+
+#define CEC0_LOG_ADDR 4 /* MBX logical address */
+#define TV_CEC_INTERVAL     (HZ*3)
+
+#define CEC_VERSION     "v1.3"
+#define _RX_DATA_BUF_SIZE_ 16
+
+#define AO_CEC  /* for switch between aocec and hdmi cec2.0 */
+
+#define MAX_MSG           16
+#define MAX_NUM_OF_DEV    16
+
+enum _cec_log_dev_addr_e {
+	CEC_TV_ADDR					= 0x00,
+	CEC_RECORDING_DEVICE_1_ADDR,
+	CEC_RECORDING_DEVICE_2_ADDR,
+	CEC_TUNER_1_ADDR,
+	CEC_PLAYBACK_DEVICE_1_ADDR,
+	CEC_AUDIO_SYSTEM_ADDR,
+	CEC_TUNER_2_ADDR,
+	CEC_TUNER_3_ADDR,
+	CEC_PLAYBACK_DEVICE_2_ADDR,
+	CEC_RECORDING_DEVICE_3_ADDR,
+	CEC_TUNER_4_ADDR,
+	CEC_PLAYBACK_DEVICE_3_ADDR,
+	CEC_RESERVED_1_ADDR,
+	CEC_RESERVED_2_ADDR,
+	CEC_FREE_USE_ADDR,
+	CEC_UNREGISTERED_ADDR
+};
+
+#define CEC_BROADCAST_ADDR CEC_UNREGISTERED_ADDR
+
+#define CEC_TV                   (1 << CEC_TV_ADDR)
+#define CEC_RECORDING_DEVICE_1   (1 << CEC_RECORDING_DEVICE_1_ADDR)
+#define CEC_RECORDING_DEVICE_2   (1 << CEC_RECORDING_DEVICE_2_ADDR)
+#define CEC_TUNER_1              (1 << CEC_TUNER_1_ADDR)
+#define CEC_PLAYBACK_DEVICE_1    (1 << CEC_PLAYBACK_DEVICE_1_ADDR)
+#define CEC_AUDIO_SYSTEM         (1 << CEC_AUDIO_SYSTEM_ADDR)
+#define CEC_TUNER_2              (1 << CEC_TUNER_2_ADDR)
+#define CEC_TUNER_3              (1 << CEC_TUNER_3_ADDR)
+#define CEC_PLAYBACK_DEVICE_2    (1 << CEC_PLAYBACK_DEVICE_2_ADDR)
+#define CEC_RECORDING_DEVICE_3   (1 << CEC_RECORDING_DEVICE_3_ADDR)
+#define CEC_TUNER_4              (1 << CEC_TUNER_4_ADDR)
+#define CEC_PLAYBACK_DEVICE_3    (1 << CEC_PLAYBACK_DEVICE_3_ADDR)
+#define CEC_RESERVED_1           (1 << CEC_RESERVED_1_ADDR)
+#define CEC_RESERVED_2           (1 << CEC_RESERVED_2_ADDR)
+#define CEC_FREE_USE             (1 << CEC_FREE_USE_ADDR)
+#define CEC_UNREGISTERED         (1 << CEC_UNREGISTERED_ADDR)
+
+#define CEC_DISPLAY_DEVICE       (CEC_TV | CEC_FREE_USE)
+#define CEC_RECORDING_DEVICE     (CEC_RECORDING_DEVICE_1 \
+	    | CEC_RECORDING_DEVICE_2 | CEC_RECORDING_DEVICE_3)
+#define CEC_PLAYBACK_DEVICE      (CEC_PLAYBACK_DEVICE_1 \
+	    | CEC_PLAYBACK_DEVICE_2 | CEC_PLAYBACK_DEVICE_3)
+#define CEC_TUNER_DEVICE         (CEC_TUNER_1 | CEC_TUNER_2 \
+	    | CEC_TUNER_3 | CEC_TUNER_4)
+#define CEC_AUDIO_SYSTEM_DEVICE  (CEC_AUDIO_SYSTEM)
+
+#define CEC_IOC_MAGIC                   'C'
+#define CEC_IOC_GET_PHYSICAL_ADDR       _IOR(CEC_IOC_MAGIC, 0x00, uint16_t)
+#define CEC_IOC_GET_VERSION             _IOR(CEC_IOC_MAGIC, 0x01, int)
+#define CEC_IOC_GET_VENDOR_ID           _IOR(CEC_IOC_MAGIC, 0x02, uint32_t)
+#define CEC_IOC_GET_PORT_INFO           _IOR(CEC_IOC_MAGIC, 0x03, int)
+#define CEC_IOC_GET_PORT_NUM            _IOR(CEC_IOC_MAGIC, 0x04, int)
+#define CEC_IOC_GET_SEND_FAIL_REASON    _IOR(CEC_IOC_MAGIC, 0x05, uint32_t)
+#define CEC_IOC_SET_OPTION_WAKEUP       _IOW(CEC_IOC_MAGIC, 0x06, uint32_t)
+#define CEC_IOC_SET_OPTION_ENALBE_CEC   _IOW(CEC_IOC_MAGIC, 0x07, uint32_t)
+#define CEC_IOC_SET_OPTION_SYS_CTRL     _IOW(CEC_IOC_MAGIC, 0x08, uint32_t)
+#define CEC_IOC_SET_OPTION_SET_LANG     _IOW(CEC_IOC_MAGIC, 0x09, uint32_t)
+#define CEC_IOC_GET_CONNECT_STATUS      _IOR(CEC_IOC_MAGIC, 0x0A, uint32_t)
+#define CEC_IOC_ADD_LOGICAL_ADDR        _IOW(CEC_IOC_MAGIC, 0x0B, uint32_t)
+#define CEC_IOC_CLR_LOGICAL_ADDR        _IOW(CEC_IOC_MAGIC, 0x0C, uint32_t)
+#define CEC_IOC_SET_DEV_TYPE            _IOW(CEC_IOC_MAGIC, 0x0D, uint32_t)
+#define CEC_IOC_SET_ARC_ENABLE          _IOW(CEC_IOC_MAGIC, 0x0E, uint32_t)
+
+#define CEC_FAIL_NONE                   0
+#define CEC_FAIL_NACK                   1
+#define CEC_FAIL_BUSY                   2
+#define CEC_FAIL_OTHER                  3
+
+enum hdmi_port_type {
+	HDMI_INPUT = 0,
+	HDMI_OUTPUT = 1
+};
+
+struct hdmi_port_info {
+	int type;
+	/* Port ID should start from 1 which corresponds to HDMI "port 1". */
+	int port_id;
+	int cec_supported;
+	int arc_supported;
+	uint16_t physical_address;
+};
+
+enum cec_dev_type_addr {
+	CEC_DISPLAY_DEVICE_TYPE = 0x0,
+	CEC_RECORDING_DEVICE_TYPE,
+	CEC_RESERVED_DEVICE_TYPE,
+	CEC_TUNER_DEVICE_TYPE,
+	CEC_PLAYBACK_DEVICE_TYPE,
+	CEC_AUDIO_SYSTEM_DEVICE_TYPE,
+	CEC_UNREGISTERED_DEVICE_TYPE,
+};
+
+enum cec_feature_abort_e {
+	CEC_UNRECONIZED_OPCODE = 0x0,
+	CEC_NOT_CORRECT_MODE_TO_RESPOND,
+	CEC_CANNOT_PROVIDE_SOURCE,
+	CEC_INVALID_OPERAND,
+	CEC_REFUSED,
+	CEC_UNABLE_TO_DETERMINE,
+};
+
+/*
+ * CEC OPCODES
+ */
+#define CEC_OC_ABORT_MESSAGE                     0xFF
+#define CEC_OC_ACTIVE_SOURCE                     0x82
+#define CEC_OC_CEC_VERSION                       0x9E
+#define CEC_OC_CLEAR_ANALOGUE_TIMER              0x33
+#define CEC_OC_CLEAR_DIGITAL_TIMER               0x99
+#define CEC_OC_CLEAR_EXTERNAL_TIMER              0xA1
+#define CEC_OC_DECK_CONTROL                      0x42
+#define CEC_OC_DECK_STATUS                       0x1B
+#define CEC_OC_DEVICE_VENDOR_ID                  0x87
+#define CEC_OC_FEATURE_ABORT                     0x00
+#define CEC_OC_GET_CEC_VERSION                   0x9F
+#define CEC_OC_GET_MENU_LANGUAGE                 0x91
+#define CEC_OC_GIVE_AUDIO_STATUS                 0x71
+#define CEC_OC_GIVE_DECK_STATUS                  0x1A
+#define CEC_OC_GIVE_DEVICE_POWER_STATUS          0x8F
+#define CEC_OC_GIVE_DEVICE_VENDOR_ID             0x8C
+#define CEC_OC_GIVE_OSD_NAME                     0x46
+#define CEC_OC_GIVE_PHYSICAL_ADDRESS             0x83
+#define CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS     0x7D
+#define CEC_OC_GIVE_TUNER_DEVICE_STATUS          0x08
+#define CEC_OC_IMAGE_VIEW_ON                     0x04
+#define CEC_OC_INACTIVE_SOURCE                   0x9D
+#define CEC_OC_MENU_REQUEST                      0x8D
+#define CEC_OC_MENU_STATUS                       0x8E
+#define CEC_OC_PLAY                              0x41
+#define CEC_OC_POLLING_MESSAGE                   0xFC
+#define CEC_OC_RECORD_OFF                        0x0B
+#define CEC_OC_RECORD_ON                         0x09
+#define CEC_OC_RECORD_STATUS                     0x0A
+#define CEC_OC_RECORD_TV_SCREEN                  0x0F
+#define CEC_OC_REPORT_AUDIO_STATUS               0x7A
+#define CEC_OC_REPORT_PHYSICAL_ADDRESS           0x84
+#define CEC_OC_REPORT_POWER_STATUS               0x90
+#define CEC_OC_REQUEST_ACTIVE_SOURCE             0x85
+#define CEC_OC_ROUTING_CHANGE                    0x80
+#define CEC_OC_ROUTING_INFORMATION               0x81
+#define CEC_OC_SELECT_ANALOGUE_SERVICE           0x92
+#define CEC_OC_SELECT_DIGITAL_SERVICE            0x93
+#define CEC_OC_SET_ANALOGUE_TIMER                0x34
+#define CEC_OC_SET_AUDIO_RATE                    0x9A
+#define CEC_OC_SET_DIGITAL_TIMER                 0x97
+#define CEC_OC_SET_EXTERNAL_TIMER                0xA2
+#define CEC_OC_SET_MENU_LANGUAGE                 0x32
+#define CEC_OC_SET_OSD_NAME                      0x47
+#define CEC_OC_SET_OSD_STRING                    0x64
+#define CEC_OC_SET_STREAM_PATH                   0x86
+#define CEC_OC_SET_SYSTEM_AUDIO_MODE             0x72
+#define CEC_OC_SET_TIMER_PROGRAM_TITLE           0x67
+#define CEC_OC_STANDBY                           0x36
+#define CEC_OC_SYSTEM_AUDIO_MODE_REQUEST         0x70
+#define CEC_OC_SYSTEM_AUDIO_MODE_STATUS          0x7E
+#define CEC_OC_TEXT_VIEW_ON                      0x0D
+#define CEC_OC_TIMER_CLEARED_STATUS              0x43
+#define CEC_OC_TIMER_STATUS                      0x35
+#define CEC_OC_TUNER_DEVICE_STATUS               0x07
+#define CEC_OC_TUNER_STEP_DECREMENT              0x06
+#define CEC_OC_TUNER_STEP_INCREMENT              0x05
+#define CEC_OC_USER_CONTROL_PRESSED              0x44
+#define CEC_OC_USER_CONTROL_RELEASED             0x45
+#define CEC_OC_VENDOR_COMMAND                    0x89
+#define CEC_OC_VENDOR_COMMAND_WITH_ID            0xA0
+#define CEC_OC_VENDOR_REMOTE_BUTTON_DOWN         0x8A
+#define CEC_OC_VENDOR_REMOTE_BUTTON_UP           0x8B
+
+/* cec global struct */
+
+enum cec_node_status_e {
+	STATE_UNKNOWN = 0x00,
+	STATE_START,
+	STATE_STOP
+};
+
+enum cec_power_status_e {
+	POWER_ON = 0x00,
+	POWER_STANDBY,
+	TRANS_STANDBY_TO_ON,
+	TRANS_ON_TO_STANDBY,
+};
+
+enum status_req_mode_e {
+	STATUS_REQ_ON = 1,
+	STATUS_REQ_OFF,
+	STATUS_REQ_ONCE,
+};
+
+enum deck_info_e {
+	DECK_UNKNOWN_STATUS = 0,
+	DECK_PLAY = 0X11,
+	DECK_RECORD,
+	DECK_PLAY_REVERSE,
+	DECK_STILL,
+	DECK_SLOW,
+	DECK_SLOW_REVERSE,
+	DECK_FAST_FORWARD,
+	DECK_FAST_REVERSE,
+	DECK_NO_MEDIA,
+	DECK_STOP,
+	DECK_SKIP_FORWARD_WIND,
+	DECK_SKIP_REVERSE_REWIND,
+	DECK_INDEX_SEARCH_FORWARD,
+	DECK_INDEX_SEARCH_REVERSE,
+	DECK_OTHER_STATUS,
+};
+
+enum deck_cnt_mode_e {
+	DECK_CNT_SKIP_FORWARD_WIND = 1,
+	DECK_CNT_SKIP_REVERSE_REWIND,
+	DECK_CNT_STOP,
+	DECK_CNT_EJECT,
+};
+
+enum play_mode_e {
+	PLAY_FORWARD = 0X24,
+	PLAY_REVERSE = 0X20,
+	PLAY_STILL = 0X25,
+	FAST_FORWARD_MIN_SPEED = 0X05,
+	FAST_FORWARD_MEDIUM_SPEED = 0X06,
+	FAST_FORWARD_MAX_SPEED = 0X07,
+	FAST_REVERSE_MIN_SPEED = 0X09,
+	FAST_REVERSE_MEDIUM_SPEED = 0X0A,
+	FAST_REVERSE_MAX_SPEED = 0X0B,
+	SLOW_FORWARD_MIN_SPEED = 0X15,
+	SLOW_FORWARD_MEDIUM_SPEED = 0X16,
+	SLOW_FORWARD_MAX_SPEED = 0X17,
+	SLOW_REVERSE_MIN_SPEED = 0X19,
+	SLOW_REVERSE_MEDIUM_SPEED = 0X1A,
+	SLOW_REVERSE_MAX_SPEED = 0X1B,
+};
+
+enum cec_version_e {
+	CEC_VERSION_11 = 0,
+	CEC_VERSION_12,
+	CEC_VERSION_12A,
+	CEC_VERSION_13,
+	CEC_VERSION_13A,
+	CEC_VERSION_14A,
+};
+
+#define INFO_MASK_CEC_VERSION                (1<<0)
+#define INFO_MASK_VENDOR_ID                  (1<<1)
+#define INFO_MASK_DEVICE_TYPE                (1<<2)
+#define INFO_MASK_POWER_STATUS               (1<<3)
+#define INFO_MASK_PHYSICAL_ADDRESS           (1<<4)
+#define INFO_MASK_LOGIC_ADDRESS              (1<<5)
+#define INFO_MASK_OSD_NAME                   (1<<6)
+#define INFO_MASK_MENU_STATE                 (1<<7)
+#define INFO_MASK_MENU_LANGUAGE              (1<<8)
+#define INFO_MASK_DECK_INfO                  (1<<9)
+#define INFO_MASK_PLAY_MODE                  (1<<10)
+
+/*CEC UI MASK*/
+#define CEC_FUNC_MSAK                        0
+#define ONE_TOUCH_PLAY_MASK                  1
+#define ONE_TOUCH_STANDBY_MASK               2
+#define AUTO_POWER_ON_MASK                   3
+
+
+struct cec_node_info_t {
+};
+
+/*
+ * only for 1 tx device
+ */
+struct cec_global_info_t {
+	dev_t dev_no;
+	unsigned int open_count;
+	unsigned int hal_ctl;			/* message controled by hal */
+	unsigned int vendor_id:24;
+	unsigned int power_status;
+	unsigned int menu_lang;
+	unsigned int cec_version;
+	unsigned int log_addr[5];
+	unsigned int menu_status;
+	unsigned char osd_name[16];
+	struct input_dev *remote_cec_dev;	/* cec input device */
+	struct hdmitx_dev *hdmitx_device;
+};
+
+enum cec_device_menu_state_e {
+	DEVICE_MENU_ACTIVE = 0,
+	DEVICE_MENU_INACTIVE,
+};
+
+int cec_ll_tx(const unsigned char *msg, unsigned char len);
+int cec_ll_rx(unsigned char *msg, unsigned char *len);
+int cec_rx_buf_check(void);
+
+void cec_pinmux_set(void);
+void cec_arbit_bit_time_set(unsigned , unsigned , unsigned);
+void cec_clear_buf(unsigned int flag);
+void cec_keep_reset(void);
+void cec_logicaddr_set(int logicaddr, int logreg);
+void cec_logicaddr_clear(void);
+void cec_logicaddr_setByMask(unsigned int mask);
+void ao_cec_init(void);
+void tx_irq_handle(void);
+
+unsigned int cec_config(unsigned int value, bool wr_flag);
+unsigned int cec_intr_stat(void);
+unsigned int cec_phyaddr_config(unsigned int value, bool wr_flag);
+unsigned int cec_logicaddr_config(unsigned int value, bool wr_flag);
+int  cec_node_init(struct hdmitx_dev *hdmitx_device);
+void cec_polling_online_dev(int log_addr, int *bool);
+void cec_imageview_on_smp(void);
+void cec_get_menu_language_smp(void);
+
+void cec_user_control_pressed_irq(unsigned char message_irq);
+void cec_user_control_released_irq(void);
+extern __u16 cec_key_map[160];
+void cec_active_source_smp(void);
+void cec_send_simplink_alive(void);
+void cec_send_simplink_ack(void);
+
+extern bool cec_msg_dbg_en;
+extern struct cec_global_info_t cec_info;
+extern void cec_rx_buf_clear(void);
+extern int get_cec_tx_fail(void);
+#endif
+
diff --git a/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h b/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
index 02d8ae4..30bbd4b 100644
--- a/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
+++ b/include/linux/amlogic/hdmi_tx/hdmi_tx_module.h
@@ -137,10 +137,6 @@ struct hdmitx_dev {
 	struct delayed_work cec_work;
 	struct timer_list hdcp_timer;
 	int hdcp_try_times;
-	/* -1, no hdcp; 0, NULL; 1, 1.4; 2, 2.2 */
-	int hdcp_mode;
-	int ready;	/* 1, hdmi stable output, others are 0 */
-	int hdcp_hpd_stick;	/* 1 not init & reset at plugout */
 #ifdef CONFIG_AML_HDMI_TX_14
 	wait_queue_head_t cec_wait_rx;
 #endif
@@ -247,11 +243,8 @@ struct hdmitx_dev {
 #define DDC_RESET_EDID          (CMD_DDC_OFFSET + 0x00)
 #define DDC_RESET_HDCP          (CMD_DDC_OFFSET + 0x01)
 #define DDC_HDCP_OP             (CMD_DDC_OFFSET + 0x02)
-	#define HDCP14_ON	0x1
-	#define HDCP14_OFF	0x2
-	#define HDCP22_ON	0x3
-	#define HDCP22_OFF	0x4
-#define DDC_HDCP_BYP		(CMD_DDC_OFFSET + 0x03)
+#define HDCP_ON             0x1
+#define HDCP_OFF            0x2
 #define DDC_IS_HDCP_ON          (CMD_DDC_OFFSET + 0x04)
 #define DDC_HDCP_GET_AKSV       (CMD_DDC_OFFSET + 0x05)
 #define DDC_HDCP_GET_BKSV       (CMD_DDC_OFFSET + 0x06)
@@ -263,9 +256,6 @@ struct hdmitx_dev {
 #define DDC_IS_EDID_DATA_READY  (CMD_DDC_OFFSET + 0x0b)
 #define DDC_EDID_GET_DATA       (CMD_DDC_OFFSET + 0x0c)
 #define DDC_EDID_CLEAR_RAM      (CMD_DDC_OFFSET + 0x0d)
-#define DDC_HDCP_MUX_INIT	(CMD_DDC_OFFSET + 0x0e)
-#define DDC_HDCP_14_LSTORE	(CMD_DDC_OFFSET + 0x0f)
-#define DDC_HDCP_22_LSTORE	(CMD_DDC_OFFSET + 0x10)
 
 /***********************************************************************
  *             CONFIG CONTROL //CntlConfig
@@ -312,8 +302,6 @@ struct hdmitx_dev {
 	#define CLR_AVMUTE	0x1
 	#define SET_AVMUTE	0x2
 #define MISC_HPLL_FAKE			(CMD_MISC_OFFSET + 0x0c)
-#define MISC_ESM_RESET		(CMD_MISC_OFFSET + 0x0d)
-#define MISC_HDCP_CLKDIS	(CMD_MISC_OFFSET + 0x0e)
 
 /***********************************************************************
  *                          Get State //GetState
@@ -346,7 +334,6 @@ struct hdmitx_dev {
  *    hdmitx protocol level interface
  **********************************************************************/
 extern void hdmitx_init_parameters(struct hdmitx_info *info);
-extern enum hdmi_vic hdmitx_edid_vic_tab_map_vic(const char *disp_mode);
 
 extern int hdmitx_edid_parse(struct hdmitx_dev *hdmitx_device);
 
-- 
1.9.1

